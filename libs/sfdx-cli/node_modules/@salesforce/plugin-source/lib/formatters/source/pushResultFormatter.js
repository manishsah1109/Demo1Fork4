/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { relative, resolve as pathResolve } from 'node:path';
import chalk from 'chalk';
import { Messages, SfError } from '@salesforce/core';
import { ComponentStatus, MetadataResolver, VirtualTreeContainer, } from '@salesforce/source-deploy-retrieve';
import { isString } from '@salesforce/ts-types';
import { ensureArray } from '@salesforce/kit';
import { ResultFormatter } from '../resultFormatter.js';
import { exitCodeAsNumber } from './statusFormatter.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-source', 'push');
export class PushResultFormatter extends ResultFormatter {
    results;
    deletes;
    fileResponses;
    replacements;
    constructor(ux, options, results, 
    // if your push included deletes that are bundle subcomponents, we'll need to add those deletes to the results even though they aren't included in fileResponses
    deletes = []) {
        super(ux, options);
        this.results = results;
        this.deletes = deletes;
        this.fileResponses = this.correctFileResponses();
        this.replacements = mergeReplacements(results);
    }
    /**
     * Get the JSON output from the DeployResult.
     *
     * @returns a JSON formatted result matching the provided type.
     */
    getJson() {
        // throws a particular json structure.
        if (process.exitCode !== 0) {
            const errorData = this.fileResponses.filter((fileResponse) => fileResponse.state === ComponentStatus.Failed);
            const error = SfError.create({
                context: 'Push',
                name: 'DeployFailed',
                exitCode: exitCodeAsNumber(),
                message: messages.getMessage('sourcepushFailed', ['']),
                data: errorData,
            });
            // matching toolbelt error json.  Does not match the SfError type
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            error.result = errorData;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            error.commandName = 'Push';
            // partial success
            if (process.exitCode === 69) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                error['partialSuccess'] = this.fileResponses.filter((fileResponse) => fileResponse.state !== ComponentStatus.Failed);
            }
            throw error;
        }
        // quiet returns only failures
        const toReturn = this.isQuiet()
            ? this.fileResponses.filter((fileResponse) => fileResponse.state === ComponentStatus.Failed)
            : this.fileResponses;
        return {
            pushedSource: toReturn.map(({ state, fullName, type, filePath }) => ({ state, fullName, type, filePath })),
            ...(!this.isQuiet() && this.replacements.size ? { replacements: Object.fromEntries(this.replacements) } : {}),
        };
    }
    /**
     * Displays deploy results in human readable format.  Output can vary based on:
     *
     * 1. Verbose option
     * 3. Checkonly deploy (checkonly=true)
     * 4. Deploy with test results
     * 5. Canceled status
     */
    display() {
        this.displaySuccesses();
        this.displayFailures();
        this.displayReplacements();
        // Throw a DeployFailed error unless the deployment was successful.
        if (!this.isSuccess()) {
            // Add error message directly on the DeployResult (e.g., a GACK)
            let errMsg = '';
            this.results?.forEach((res) => {
                if (res.response?.errorMessage) {
                    errMsg += `${res.response?.errorMessage}\n`;
                }
            });
            throw new SfError(messages.getMessage('sourcepushFailed', [errMsg]), 'PushFailed');
        }
    }
    correctFileResponses() {
        const withoutUnchanged = this.results.some((result) => result.getFileResponses().length)
            ? this.results.flatMap((result) => result.getFileResponses().filter((fileResponse) => fileResponse.state !== ComponentStatus.Unchanged))
            : [];
        if (!this.deletes.length) {
            return withoutUnchanged;
        }
        const bundlesDeployed = withoutUnchanged.filter((fileResponse) => [
            'LightningComponentBundle',
            'AuraDefinitionBundle',
            'WaveTemplateBundle',
            'ExperiencePropertyTypeBundle',
        ].includes(fileResponse.type));
        if (bundlesDeployed.length === 0) {
            return withoutUnchanged;
        }
        // "content" property of the bundles as a string
        const contentFilePathFromDeployedBundles = this.componentsFromFilenames(bundlesDeployed.map((fileResponse) => fileResponse.filePath).filter(isString))
            .map((c) => c.content)
            .filter(isString);
        // there may be deletes not represented in the file responses (if bundle type)
        const resolver = new MetadataResolver(undefined, VirtualTreeContainer.fromFilePaths(this.deletes));
        return withoutUnchanged.concat(this.deletes.flatMap((filePath) => this.resolveComponentsOrWarn(filePath, resolver)
            .filter((cmp) => cmp.type.strategies?.adapter === 'bundle' &&
            contentFilePathFromDeployedBundles.includes(pathResolve(cmp.content ?? '')))
            .map((cmp) => ({
            state: ComponentStatus.Deleted,
            fullName: cmp.fullName,
            type: cmp.type.name,
            filePath,
        }))));
    }
    displaySuccesses() {
        if (this.isQuiet()) {
            return;
        }
        if (this.isSuccess() && this.fileResponses?.length) {
            const successes = this.fileResponses.filter((f) => f.state !== ComponentStatus.Failed);
            if (!successes.length) {
                return;
            }
            this.sortFileResponses(successes);
            this.asRelativePaths(successes);
            this.ux.log('');
            this.ux.styledHeader(chalk.blue('Pushed Source'));
            this.ux.table(successes.map((entry) => ({
                state: entry.state,
                fullName: entry.fullName,
                type: entry.type,
                filePath: entry.filePath,
            })), {
                state: { header: 'STATE' },
                fullName: { header: 'FULL NAME' },
                type: { header: 'TYPE' },
                filePath: { header: 'PROJECT PATH' },
            });
        }
    }
    displayReplacements() {
        if (!this.isQuiet() && this.replacements.size) {
            this.ux.log('');
            this.ux.styledHeader(chalk.blue('Metadata Replacements'));
            const replacements = Array.from(this.replacements.entries()).flatMap(([filepath, stringsReplaced]) => stringsReplaced.map((replaced) => ({
                filePath: relative(process.cwd(), filepath),
                replaced,
            })));
            this.ux.table(replacements, {
                filePath: { header: 'PROJECT PATH' },
                replaced: { header: 'TEXT REPLACED' },
            });
        }
    }
    displayFailures() {
        const failures = [];
        const fileResponseFailures = new Map();
        if (this.fileResponses?.length) {
            const fileResponses = [];
            this.fileResponses
                .filter((f) => f.state === ComponentStatus.Failed)
                .map((f) => {
                // we've filtered all of the file responses to failed errors with the state filter  above
                fileResponses.push(f);
                fileResponseFailures.set(`${f.type}#${f.fullName}`, f.error);
            });
            this.sortFileResponses(fileResponses);
            this.asRelativePaths(fileResponses);
            failures.push(...fileResponses);
        }
        const deployMessages = this.results?.flatMap((result) => ensureArray(result.response?.details?.componentFailures));
        if (deployMessages.length > failures.length) {
            // if there's additional failures in the API response, find the failure and add it to the output
            deployMessages.map((deployMessage) => {
                if (!fileResponseFailures.has(`${deployMessage.componentType ?? ''}#${deployMessage.fullName}`)) {
                    // duplicate the problem message to the error property for displaying in the table
                    failures.push(Object.assign(deployMessage, { error: deployMessage.problem }));
                }
            });
        }
        if (!failures.length) {
            return;
        }
        this.ux.log('');
        this.ux.styledHeader(chalk.red(`Component Failures [${failures.length}]`));
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.ux.table(failures, {
            problemType: { header: 'Type' },
            fullName: { header: 'Name' },
            error: { header: 'Problem' },
        });
        this.ux.log('');
    }
    componentsFromFilenames(filenames) {
        const resolver = new MetadataResolver(undefined, VirtualTreeContainer.fromFilePaths(filenames));
        return filenames.flatMap((filename) => this.resolveComponentsOrWarn(filename, resolver));
    }
    resolveComponentsOrWarn(filename, resolver) {
        try {
            return resolver.getComponentsFromPath(filename);
        }
        catch (e) {
            this.ux.warn(`unable to resolve ${filename}`);
            return [];
        }
    }
}
export const mergeReplacements = (results) => {
    const merged = new Map();
    const replacements = results.filter((result) => result.replacements?.size).map((result) => result.replacements);
    replacements.forEach((replacement) => {
        replacement.forEach((value, key) => {
            if (!merged.has(key)) {
                merged.set(key, value);
            }
            else {
                merged.set(key, Array.from(new Set([...(merged.get(key) ?? []), ...value])));
            }
        });
    });
    return merged;
};
//# sourceMappingURL=pushResultFormatter.js.map