/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import chalk from 'chalk';
import { getNumber } from '@salesforce/ts-types';
import { Duration } from '@salesforce/kit';
import { ProgressFormatter } from './progressFormatter.js';
export class DeployProgressStatusFormatter extends ProgressFormatter {
    options;
    previousComponents = -1;
    previousTests = -1;
    constructor(ux, options) {
        super(ux);
        this.options = options;
    }
    // This can be used to print the progress of the deployment.
    progress(deploy) {
        deploy.onUpdate((data) => {
            // Print status when:
            //   1. Number of deployed components increases
            //   2. Number of tests completed increases
            //   3. Command is running in verbose mode (for updates on each poll)
            if (data.numberComponentsDeployed > this.previousComponents ||
                data.numberTestsCompleted > this.previousTests ||
                this.options?.verbose) {
                this.printDeployStatus(data);
                this.previousComponents = data.numberComponentsDeployed;
                this.previousTests = data.numberTestsCompleted;
            }
        });
        deploy.onFinish((data) => {
            this.printDeployStatus(data.response);
        });
        deploy.onError((error) => {
            throw error;
        });
    }
    // Prints Deploying status
    printDeployStatus(data) {
        if (!data.done) {
            this.ux.log('');
            this.ux.styledHeader(chalk.yellow(`Status: ${data.status}`));
            this.ux.log('');
        }
        else {
            if (data.completedDate) {
                const deployStart = new Date(data.createdDate).getTime();
                const deployEnd = new Date(data.completedDate).getTime();
                const duration = Duration.seconds((deployEnd - deployStart) / 1000);
                this.ux.log(`Deployment finished in ${duration.toString()} `);
            }
            this.ux.log('');
            const header = data.success ? chalk.green(`Result: ${data.status}`) : chalk.red(`Result: ${data.status}`);
            this.ux.styledHeader(header);
            this.ux.log('');
        }
        const componentsTotal = getNumber(data, 'numberComponentsTotal');
        if (componentsTotal) {
            const componentsDeployed = getNumber(data, 'numberComponentsDeployed');
            const componentErrors = getNumber(data, 'numberComponentErrors');
            const testsTotal = getNumber(data, 'numberTestsTotal');
            const testsCompleted = getNumber(data, 'numberTestsCompleted');
            const testErrors = getNumber(data, 'numberTestErrors');
            const deploys = `${componentsDeployed ?? 0}/${componentsTotal ?? 0} components deployed.`;
            const deployErrors = componentErrors === 1 ? `${componentErrors} error.` : `${componentErrors ?? 0} errors.`;
            const tests = `${testsCompleted ?? 0}/${testsTotal ?? 0} tests completed.`;
            const testErrs = testErrors === 1 ? `${testErrors} error.` : `${testErrors ?? 0} errors.`;
            this.ux.log(`${deploys} ${deployErrors}`);
            this.ux.log(`${tests} ${testErrs}`);
        }
        else {
            this.ux.log('No components deployed');
        }
        this.ux.log('');
    }
}
//# sourceMappingURL=deployProgressStatusFormatter.js.map