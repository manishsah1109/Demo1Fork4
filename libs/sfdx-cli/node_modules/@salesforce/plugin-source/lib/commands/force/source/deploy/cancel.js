/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Messages, SfError } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
import { RequestStatus } from '@salesforce/source-deploy-retrieve';
import { Flags, loglevel, orgApiVersionFlagWithDeprecations, requiredOrgFlagWithDeprecations, Ux, } from '@salesforce/sf-plugins-core';
import { DeployCommand } from '../../../../deployCommand.js';
import { DeployCancelResultFormatter, } from '../../../../formatters/deployCancelResultFormatter.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-source', 'cancel');
const replacement = 'project deploy cancel';
export class Cancel extends DeployCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static state = 'deprecated';
    static hidden = true;
    static deprecationOptions = {
        to: replacement,
        message: messages.getMessage('deprecation', [replacement]),
    };
    static flags = {
        'api-version': orgApiVersionFlagWithDeprecations,
        loglevel,
        'target-org': requiredOrgFlagWithDeprecations,
        wait: Flags.duration({
            unit: 'minutes',
            char: 'w',
            default: Duration.minutes(DeployCommand.DEFAULT_WAIT_MINUTES),
            min: 1,
            description: messages.getMessage('flags.wait.description'),
            summary: messages.getMessage('flags.wait.summary'),
        }),
        jobid: Flags.salesforceId({
            char: 'i',
            summary: messages.getMessage('flags.jobid.summary'),
            startsWith: '0Af',
        }),
    };
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    flags;
    async run() {
        this.flags = (await this.parse(Cancel)).flags;
        await this.cancel();
        this.resolveSuccess();
        return this.formatResult();
    }
    async cancel() {
        const conn = this.flags['target-org'].getConnection(this.flags['api-version']);
        const deployId = this.resolveDeployId(this.flags.jobid);
        try {
            const deploy = this.createDeploy(conn, deployId);
            await deploy.cancel();
            this.deployResult = await this.poll(conn, deployId);
        }
        catch (e) {
            const err = e;
            throw new SfError(messages.getMessage('CancelFailed', [err.message]), 'CancelFailed');
        }
    }
    resolveSuccess() {
        const status = this.deployResult?.response.status;
        if (status !== RequestStatus.Canceled) {
            this.setExitCode(1);
        }
    }
    formatResult() {
        const formatter = new DeployCancelResultFormatter(new Ux({ jsonEnabled: this.jsonEnabled() }), this.deployResult);
        if (!this.jsonEnabled()) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
//# sourceMappingURL=cancel.js.map