/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Messages } from '@salesforce/core';
import { Flags, loglevel, orgApiVersionFlagWithDeprecations, requiredOrgFlagWithDeprecations, SfCommand, Ux, } from '@salesforce/sf-plugins-core';
import { StatusFormatter, } from '../../../formatters/source/statusFormatter.js';
import { trackingSetup } from '../../../trackingFunctions.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-source', 'status');
const replacement = 'project retrieve/deploy preview';
export default class Status extends SfCommand {
    static summary = messages.getMessage('summary');
    static examples = messages.getMessages('examples');
    static state = 'deprecated';
    static hidden = true;
    static deprecationOptions = {
        to: replacement,
        message: messages.getMessage('deprecation', [replacement]),
    };
    static flags = {
        'api-version': orgApiVersionFlagWithDeprecations,
        loglevel,
        'target-org': requiredOrgFlagWithDeprecations,
        local: Flags.boolean({
            char: 'l',
            summary: messages.getMessage('flags.local.summary'),
            exclusive: ['remote'],
        }),
        remote: Flags.boolean({
            char: 'r',
            summary: messages.getMessage('flags.remote.summary'),
            exclusive: ['local'],
        }),
        concise: Flags.boolean({
            summary: messages.getMessage('flags.concise.summary'),
        }),
    };
    static requiresProject = true;
    results = new Array();
    localAdds = [];
    flags;
    async run() {
        this.flags = (await this.parse(Status)).flags;
        const tracking = await trackingSetup({
            ignoreConflicts: true,
            org: this.flags['target-org'],
            project: this.project,
            ux: new Ux({ jsonEnabled: this.jsonEnabled() }),
        });
        const wantsLocal = this.flags.local || (!this.flags.remote && !this.flags.local);
        const wantsRemote = this.flags.remote || (!this.flags.remote && !this.flags.local);
        this.debug(`project is ${this.project.getPath()} and pkgDirs are ${this.project.getPackageDirectories()
            .map((dir) => dir.path)
            .join(',')}`);
        const stlStatusResult = await tracking.getStatus({ local: wantsLocal, remote: wantsRemote });
        this.results = stlStatusResult.map((result) => resultConverter(result));
        return this.formatResult();
    }
    formatResult() {
        const formatter = new StatusFormatter(new Ux({ jsonEnabled: this.jsonEnabled() }), { concise: this.flags.concise }, this.results);
        if (!this.flags.json) {
            formatter.display();
        }
        return formatter.getJson();
    }
}
/**
 * STL provides a more useful json output.
 * This function makes it consistent with the Status command's json.
 */
const resultConverter = (input) => {
    const { fullName, type, ignored, filePath, conflict } = input;
    const origin = originMap.get(input.origin);
    const actualState = stateMap.get(input.state);
    return {
        fullName,
        type,
        // this string became the place to store information.
        // The JSON now breaks out that info but preserves this property for backward compatibility
        state: `${origin} ${actualState}${conflict ? ' (Conflict)' : ''}`,
        ignored,
        filePath,
        origin,
        actualState,
        conflict,
    };
};
const originMap = new Map([
    ['local', 'Local'],
    ['remote', 'Remote'],
]);
const stateMap = new Map([
    ['delete', 'Deleted'],
    ['add', 'Add'],
    ['modify', 'Changed'],
    ['nondelete', 'Changed'],
]);
//# sourceMappingURL=status.js.map