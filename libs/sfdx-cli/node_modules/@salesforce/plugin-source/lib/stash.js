/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import fs from 'node:fs';
import { ConfigFile, Logger, Messages, SfError } from '@salesforce/core';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
export class Stash {
    static KEYS = {
        MDAPI_DEPLOY: 'MDAPI_DEPLOY',
        MDAPI_RETRIEVE: 'MDAPI_RETRIEVE',
        SOURCE_DEPLOY: 'SOURCE_DEPLOY',
    };
    // singleton instance of the stash file
    static instance;
    static logger;
    // A map of Command.id to stash keys
    static keyMap = {
        'force:mdapi:deploy': Stash.KEYS.MDAPI_DEPLOY,
        'force:mdapi:deploy:cancel': Stash.KEYS.MDAPI_DEPLOY,
        'force:mdapi:deploy:report': Stash.KEYS.MDAPI_DEPLOY,
        'force:mdapi:beta:deploy': Stash.KEYS.MDAPI_DEPLOY,
        'force:mdapi:beta:deploy:cancel': Stash.KEYS.MDAPI_DEPLOY,
        'force:mdapi:beta:deploy:report': Stash.KEYS.MDAPI_DEPLOY,
        'force:source:deploy': Stash.KEYS.SOURCE_DEPLOY,
        'force:source:deploy:cancel': Stash.KEYS.SOURCE_DEPLOY,
        'force:source:deploy:report': Stash.KEYS.SOURCE_DEPLOY,
        'force:mdapi:retrieve': Stash.KEYS.MDAPI_RETRIEVE,
        'force:mdapi:retrieve:report': Stash.KEYS.MDAPI_RETRIEVE,
        'force:mdapi:beta:retrieve': Stash.KEYS.MDAPI_RETRIEVE,
        'force:mdapi:beta:retrieve:report': Stash.KEYS.MDAPI_RETRIEVE,
    };
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() { }
    /**
     * Returns the value for the given stash key.
     *
     * @param key The StashKey
     * @returns The stash value for the given key.
     */
    static get(key) {
        const stash = Stash.getStashFile();
        Stash.logger.debug(`Getting ${key} data from ${stash.getPath()}`);
        return stash.get(key);
    }
    /**
     * Returns the `StashKey` used by the Command.
     *
     * Within a command class you would typically call this as:
     *
     * `const stashEntry = Stash.get(Stash.getKey(this.id));`
     *
     * @param commandId The oclif Command.id.  E.g., `this.id`
     * @returns the `StashKey` to use for `Stash.get()` and `Stash.set()`
     */
    static getKey(commandId) {
        const key = Stash.keyMap[commandId];
        if (!key) {
            const messages = Messages.loadMessages('@salesforce/plugin-source', 'stash');
            throw new SfError(messages.getMessage('InvalidStashKey', [commandId]), 'InvalidStashKey');
        }
        return key;
    }
    /**
     * Sets deploy/retrieve data in the stash.
     *
     * @param key the `StashKey` for setting stashed deploy/retrieve values
     * @param data the `StashData` to persist.
     */
    static set(key, data) {
        const stash = Stash.getStashFile();
        stash.set(key, data);
        Stash.logger.debug(`Stashing ${key} data: ${JSON.stringify(data)} in ${stash.getPath()}`);
        stash.writeSync();
    }
    /**
     * Clears all stash file entries.
     */
    static clear() {
        const stash = Stash.getStashFile();
        Stash.logger.debug(`Clearing all stash contents in: ${stash.getPath()}`);
        stash.clear();
        stash.writeSync();
    }
    static init() {
        Stash.logger = Logger.childFromRoot('source-plugin-stash');
        Stash.instance = new ConfigFile({ isGlobal: true, filename: 'stash.json' });
    }
    static getStashFile() {
        try {
            if (!Stash.instance) {
                Stash.init();
            }
            if (Stash.instance.existsSync()) {
                // Always read from the stash file before returning it
                Stash.instance.readSync(true);
            }
            else {
                Stash.instance.writeSync();
            }
        }
        catch (err) {
            const error = err;
            if (error.name === 'JsonParseError') {
                const stashFilePath = Stash.instance?.getPath();
                const corruptFilePath = `${stashFilePath}_corrupted_${Date.now()}`;
                fs.renameSync(stashFilePath, corruptFilePath);
                const messages = Messages.loadMessages('@salesforce/plugin-source', 'stash');
                throw new SfError(`${messages.getMessage('InvalidStashKey', [corruptFilePath])}\n\n${error.message}`, 'InvalidStashFile', [], error);
            }
            throw SfError.wrap(error);
        }
        return Stash.instance;
    }
}
//# sourceMappingURL=stash.js.map