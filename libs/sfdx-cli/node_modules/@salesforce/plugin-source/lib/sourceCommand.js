/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { dirname, resolve, extname } from 'node:path';
import fs from 'node:fs';
import { Messages, SfError } from '@salesforce/core';
import { getString } from '@salesforce/ts-types';
import { SingleBar } from 'cli-progress';
import { SfCommand } from '@salesforce/sf-plugins-core';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-source', 'flags.validation');
export class SourceCommand extends SfCommand {
    static DEFAULT_WAIT_MINUTES = 33;
    progressBar;
    componentSet;
    initProgressBar() {
        this.debug('initializing progress bar');
        this.progressBar = new SingleBar({
            format: 'SOURCE PROGRESS | {bar} | {value}/{total} Components',
            barCompleteChar: '\u2588',
            barIncompleteChar: '\u2591',
            linewrap: true,
        });
    }
    /**
     * Sets an exit code on the process that marks success or failure
     * after successful command execution.
     *
     * @param code The exit code to set on the process.
     */
    // eslint-disable-next-line class-methods-use-this
    setExitCode(code) {
        process.exitCode = code;
    }
    getPackageDirs() {
        return this.project.getUniquePackageDirectories().map((pDir) => pDir.fullPath);
    }
    async getSourceApiVersion() {
        const projectConfig = await this.project.resolveProjectConfig();
        return getString(projectConfig, 'sourceApiVersion');
    }
    /**
     * Ensures command flags that are file system paths are set properly before
     * continuing command execution.  Can also create directories that don't yet
     * exist in the path.
     *
     * @param options defines the path to resolve and the expectations
     * @returns the resolved flag path
     */
    // eslint-disable-next-line class-methods-use-this
    ensureFlagPath(options) {
        const { flagName, path, type, throwOnENOENT } = options;
        const trimmedPath = path?.trim();
        let resolvedPath = '';
        if (trimmedPath?.length) {
            resolvedPath = resolve(trimmedPath);
        }
        try {
            const stats = fs.statSync(resolvedPath);
            if (type !== 'any') {
                const isDir = stats.isDirectory();
                if (type === 'dir' && !isDir) {
                    const msg = messages.getMessage('expectedDirectory');
                    throw new SfError(messages.getMessage('InvalidFlagPath', [flagName, path, msg]), 'InvalidFlagPath');
                }
                else if (type === 'file' && isDir) {
                    const msg = messages.getMessage('expectedFile');
                    throw new SfError(messages.getMessage('InvalidFlagPath', [flagName, path, msg]), 'InvalidFlagPath');
                }
            }
        }
        catch (error) {
            const err = error;
            if (err.code !== 'ENOENT') {
                throw err;
            }
            else {
                if (throwOnENOENT) {
                    const enoent = messages.getMessage('notFound');
                    throw new SfError(messages.getMessage('InvalidFlagPath', [flagName, path, enoent]), 'InvalidFlagPath');
                }
                const dir = type === 'dir' ? resolvedPath : dirname(resolvedPath);
                fs.mkdirSync(dir, { recursive: true });
            }
        }
        return resolvedPath;
    }
}
export const resolveZipFileName = (zipFileName) => {
    // If no file extension was provided append, '.zip'
    if (zipFileName && !extname(zipFileName)) {
        zipFileName += '.zip';
    }
    return zipFileName ?? 'unpackaged.zip';
};
//# sourceMappingURL=sourceCommand.js.map