/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import fs from 'node:fs';
import { Logger, Messages } from '@salesforce/core';
import { isFulfilled } from '@salesforce/kit';
import { flattenNestedRecords } from '../../../export.js';
import { isAttributesEntry } from '../../../types.js';
import { sendSObjectTreeRequest, treeSaveErrorHandler, parseDataFileContents, getResultsIfNoError, } from './importCommon.js';
import { hasUnresolvedRefs } from './functions.js';
export const importFromFiles = async (conn, dataFilePaths) => {
    const logger = Logger.childFromRoot('data:import:tree:importSObjectTreeFile');
    const fileInfos = (await Promise.all(dataFilePaths.map(parseFile))).map(logFileInfo(logger)).map(validateNoRefs);
    const refMap = createSObjectTypeMap(fileInfos.flatMap((fi) => fi.records));
    const results = await Promise.allSettled(fileInfos.map((fi) => sendSObjectTreeRequest(conn)(fi.sobject)(fi.rawContents)));
    return results.map(getSuccessOrThrow).flatMap(getValueOrThrow(fileInfos)).map(addObjectTypes(refMap));
};
const getSuccessOrThrow = (result) => isFulfilled(result) ? result : treeSaveErrorHandler(result.reason);
const getValueOrThrow = (fi) => (response, index) => getResultsIfNoError(fi[index].filePath)(response.value);
const addObjectTypes = (refMap) => (result) => ({
    refId: result.referenceId,
    type: refMap.get(result.referenceId) ?? 'Unknown',
    id: result.id,
});
const contentsToSobjectType = (records) => records[0].attributes.type;
const logFileInfo = (logger) => (fileInfo) => {
    logger.debug(`Parsed file ${fileInfo.filePath} for sobject type ${fileInfo.sobject}`);
    return fileInfo;
};
/** check the tree files for references, throw error telling user they are only supported with `--plan */
export const validateNoRefs = (fileInfo) => {
    if (hasUnresolvedRefs(fileInfo.records)) {
        Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
        const messages = Messages.loadMessages('@salesforce/plugin-data', 'importApi');
        throw new Error(messages.getMessage('error.RefsInFiles', [fileInfo.filePath]));
    }
    return fileInfo;
};
/** gets information about the file, including the sobject, contents, parsed contents */
const parseFile = async (filePath) => {
    const rawContents = await fs.promises.readFile(filePath, 'utf8');
    const records = parseDataFileContents(filePath)(rawContents);
    const sobjectType = contentsToSobjectType(records);
    return { rawContents, records, filePath, sobject: sobjectType };
};
/** Create a hash of sobject { ReferenceId: Type }. */
export const createSObjectTypeMap = (records) => new Map(records
    .flatMap(flattenNestedRecords)
    .flatMap(Object.entries)
    .filter(isAttributesEntry)
    .map(([, val]) => [val.referenceId, val.type]));
//# sourceMappingURL=importFiles.js.map