"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryReporter = exports.TelemetryClient = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = __importStar(require("node:os"));
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const got_1 = __importDefault(require("got"));
const proxy_agent_1 = require("proxy-agent");
const appInsights_1 = require("./appInsights");
const enabledCheck_1 = require("./enabledCheck");
var appInsights_2 = require("./appInsights");
Object.defineProperty(exports, "TelemetryClient", { enumerable: true, get: function () { return appInsights_2.TelemetryClient; } });
/**
 * Reports telemetry events to app insights. We do not send if the config 'disableTelemetry' is set.
 */
class TelemetryReporter extends kit_1.AsyncCreatable {
    enabled = false;
    options;
    logger;
    reporter;
    constructor(options) {
        super(options);
        this.options = options;
    }
    /**
     * @deprecated Use the standalone function isEnabled() instead.
     * Determine if the telemetry event should be logged.
     * Setting the disableTelemetry config var to true will disable insights for errors and diagnostics.
     */
    static async determineSfdxTelemetryEnabled() {
        return (0, enabledCheck_1.isEnabled)();
    }
    async init() {
        this.enabled = await (0, enabledCheck_1.isEnabled)();
        this.logger = await core_1.Logger.child('TelemetryReporter');
        if (this.options.waitForConnection)
            await this.waitForConnection();
        this.reporter = await appInsights_1.AppInsights.create(this.options);
    }
    /**
     * Starts data collection services. This is for long running processes. Short lived
     * processes can call send*Event directly then finish it by TelemetryReporter.stop().
     */
    start() {
        this.reporter.start();
    }
    /**
     * Immediately flush and dispose of the reporter. This can usually take 1-3 seconds
     * not counting timeouts.
     */
    stop() {
        this.reporter.stop();
    }
    async waitForConnection() {
        const canConnect = await this.testConnection();
        if (!canConnect) {
            throw new Error('Unable to connect to app insights.');
        }
    }
    async testConnection() {
        const timeout = parseInt(kit_1.env.getString('SFDX_TELEMETRY_TIMEOUT', '1000'), 10);
        this.logger.debug(`Testing connection to ${appInsights_1.AppInsights.APP_INSIGHTS_SERVER} with timeout of ${timeout} ms`);
        try {
            const resp = await got_1.default.get(appInsights_1.AppInsights.APP_INSIGHTS_SERVER, {
                throwHttpErrors: false,
                agent: { https: new proxy_agent_1.ProxyAgent() },
                retry: {
                    methods: ['GET'],
                    errorCodes: ['ECONNRESET', 'EADDRINUSE', 'ECONNREFUSED', 'EPIPE'],
                },
                timeout: {
                    lookup: 100,
                    send: 10_000,
                    response: 1000,
                },
            });
            if (resp.statusCode < 500) {
                this.logger.debug(`Successfully made a connection to ${appInsights_1.AppInsights.APP_INSIGHTS_SERVER}`);
                return true;
            }
            this.logger.error(`${appInsights_1.AppInsights.APP_INSIGHTS_SERVER} responded with ${resp.statusCode}`);
            throw new Error(resp.statusCode.toString());
        }
        catch (err) {
            this.logger.warn(`Connection to ${appInsights_1.AppInsights.APP_INSIGHTS_SERVER} timed out after ${timeout} ms`);
            return false;
        }
    }
    /**
     * Sends message to child process.
     *
     * @param eventName {string} - name of the event you want published.
     * @param attributes {Attributes} - map of properties to publish alongside the event.
     */
    sendTelemetryEvent(eventName, attributes = {}) {
        if (this.isSfdxTelemetryEnabled()) {
            this.reporter.sendTelemetryEvent(eventName, attributes);
        }
    }
    /**
     * Sends exception to child process.
     *
     * @param exception {Error} - exception you want published.
     * @param attributes {Attributes} - map of measurements to publish alongside the event.
     */
    sendTelemetryException(exception, attributes = {}) {
        if (this.isSfdxTelemetryEnabled()) {
            // Scrub stack for GDPR
            exception.stack = exception.stack?.replace(new RegExp(os.homedir(), 'g'), appInsights_1.AppInsights.GDPR_HIDDEN);
            this.reporter.sendTelemetryException(exception, attributes);
        }
    }
    /**
     * Publishes diagnostic information to app insights dashboard
     *
     * @param traceMessage {string} - trace message to sen to app insights.
     * @param properties {Properties} - map of properties to publish alongside the event.
     */
    sendTelemetryTrace(traceMessage, properties) {
        if (this.isSfdxTelemetryEnabled()) {
            this.reporter.sendTelemetryTrace(traceMessage, properties);
        }
    }
    /**
     * Publishes metric to app insights dashboard
     *
     * @param metricName {string} - name of the metric you want published
     * @param value {number} - value of the metric
     * @param properties {Properties} - map of properties to publish alongside the event.
     */
    sendTelemetryMetric(metricName, value, properties) {
        if (this.isSfdxTelemetryEnabled()) {
            this.reporter.sendTelemetryMetric(metricName, value, properties);
        }
    }
    /**
     * Determine if the telemetry event should be logged.
     * Setting the disableTelemetry config var to true will disable insights for errors and diagnostics.
     */
    isSfdxTelemetryEnabled() {
        return this.enabled;
    }
    logTelemetryStatus() {
        if (this.enabled) {
            this.logger.warn(`Telemetry is enabled. This can be disabled by running sfdx force:config:set ${core_1.SfConfigProperties.DISABLE_TELEMETRY}=true`);
        }
        else {
            this.logger.warn(`Telemetry is disabled. This can be enabled by running sfdx force:config:set ${core_1.SfConfigProperties.DISABLE_TELEMETRY}=false`);
        }
    }
    /**
     * Gets the underline telemetry client. This should only be used to set
     * additional options that are not exposed in the init options. This should
     * NOT be used to send events as it will by pass disabled checks.
     */
    getTelemetryClient() {
        return this.reporter.appInsightsClient;
    }
}
exports.TelemetryReporter = TelemetryReporter;
//# sourceMappingURL=telemetryReporter.js.map