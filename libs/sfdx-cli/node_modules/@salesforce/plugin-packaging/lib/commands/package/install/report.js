/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Flags, loglevel, orgApiVersionFlagWithDeprecations, requiredOrgFlagWithDeprecations, SfCommand, } from '@salesforce/sf-plugins-core';
import { Messages } from '@salesforce/core';
import { SubscriberPackageVersion } from '@salesforce/packaging';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-packaging', 'package_install_report');
const installMsgs = Messages.loadMessages('@salesforce/plugin-packaging', 'package_install');
export class Report extends SfCommand {
    static summary = messages.getMessage('summary');
    static examples = messages.getMessages('examples');
    static deprecateAliases = true;
    static aliases = ['force:package:install:report'];
    static org;
    static flags = {
        'target-org': requiredOrgFlagWithDeprecations,
        'api-version': orgApiVersionFlagWithDeprecations,
        loglevel,
        'request-id': Flags.salesforceId({
            startsWith: '0Hf',
            length: 'both',
            char: 'i',
            deprecateAliases: true,
            aliases: ['requestid'],
            summary: messages.getMessage('flags.request-id.summary'),
            required: true,
        }),
    };
    static parseStatus(binName, request, username, alias) {
        const pkgIdOrAlias = alias ?? request.SubscriberPackageVersionKey;
        const { Status } = request;
        if (Status === 'SUCCESS') {
            return installMsgs.getMessage('package-install-success', [pkgIdOrAlias]);
        }
        else if (['IN_PROGRESS', 'UNKNOWN'].includes(Status)) {
            return installMsgs.getMessage('packageInstallInProgress', [binName, request.Id, username]);
        }
        else {
            let errorMessage = '<empty>';
            const errors = request?.Errors?.errors;
            if (errors?.length) {
                errorMessage = 'Installation errors: ';
                for (let i = 0; i < errors.length; i++) {
                    errorMessage += `\n${i + 1}) ${errors[i].message}`;
                }
            }
            throw installMsgs.createError('packageInstallError', [errorMessage]);
        }
    }
    async run() {
        const { flags } = await this.parse(Report);
        const connection = flags['target-org'].getConnection(flags['api-version']);
        const pkgInstallRequest = await SubscriberPackageVersion.getInstallRequest(flags['request-id'], connection);
        this.log(Report.parseStatus(this.config.bin, pkgInstallRequest, flags['target-org'].getUsername()));
        return pkgInstallRequest;
    }
}
//# sourceMappingURL=report.js.map