"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateTypesAndNames = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const logger_1 = require("@salesforce/core/logger");
const ts_types_1 = require("@salesforce/ts-types");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const guards_1 = require("./guards");
const functions_1 = require("./functions");
/**
 * uses SDR to translate remote metadata records into local file paths (which only typically have the filename).
 *
 * @input elements: ChangeResult[]
 * @input projectPath
 * @input forceIgnore: ForceIgnore.  If provided, result will indicate whether the file is ignored
 * @input excludeUnresolvable: boolean Filter out components where you can't get the name and type (that is, it's probably not a valid source component)
 * @input resolveDeleted: constructs a virtualTree instead of the actual filesystem--useful when the files no longer exist
 */
const populateTypesAndNames = ({ projectPath, forceIgnore, excludeUnresolvable = false, resolveDeleted = false, registry, }) => (elements) => {
    if (elements.length === 0) {
        return [];
    }
    const logger = logger_1.Logger.childFromRoot('SourceTracking.PopulateTypesAndNames');
    logger.debug(`populateTypesAndNames for ${elements.length} change elements`);
    const filenames = elements.flatMap((element) => element.filenames).filter(ts_types_1.isString);
    // component set generated from the filenames on all local changes
    const resolver = new source_deploy_retrieve_1.MetadataResolver(registry, resolveDeleted ? source_deploy_retrieve_1.VirtualTreeContainer.fromFilePaths(filenames) : undefined, !!forceIgnore);
    const sourceComponents = filenames
        .flatMap((filename) => {
        try {
            return resolver.getComponentsFromPath(filename);
        }
        catch (e) {
            logger.warn(`unable to resolve ${filename}`);
            return undefined;
        }
    })
        .filter(guards_1.isDefined);
    logger.debug(` matching SourceComponents have ${sourceComponents.length} items from local`);
    const elementMap = new Map(elements.flatMap((e) => (e.filenames ?? []).map((f) => [(0, functions_1.ensureRelative)(projectPath)(f), e])));
    // iterates the local components and sets their filenames
    sourceComponents.filter(functions_1.sourceComponentHasFullNameAndType).map((matchingComponent) => {
        const filenamesFromMatchingComponent = (0, functions_1.getAllFiles)(matchingComponent);
        const ignored = filenamesFromMatchingComponent
            .filter(functions_1.excludeLwcLocalOnlyTest)
            .some((0, functions_1.forceIgnoreDenies)(forceIgnore));
        filenamesFromMatchingComponent.map((filename) => {
            if (filename && elementMap.has(filename)) {
                // add the type/name from the componentSet onto the element
                elementMap.set(filename, {
                    origin: 'remote',
                    ...elementMap.get(filename),
                    type: matchingComponent.type.name,
                    name: matchingComponent.fullName,
                    ignored,
                });
            }
        });
    });
    return excludeUnresolvable
        ? Array.from(new Set(elementMap.values())).filter(guards_1.isChangeResultWithNameAndType)
        : Array.from(new Set(elementMap.values()));
};
exports.populateTypesAndNames = populateTypesAndNames;
//# sourceMappingURL=populateTypesAndNames.js.map