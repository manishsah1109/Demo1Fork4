"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDedupedConflictsFromChanges = exports.findConflictsInComponentSet = exports.throwIfConflicts = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_path_1 = require("node:path");
const types_1 = require("./types");
const functions_1 = require("./functions");
const populateTypesAndNames_1 = require("./populateTypesAndNames");
const guards_1 = require("./guards");
const throwIfConflicts = (conflicts) => {
    if (conflicts.length > 0) {
        throw new types_1.SourceConflictError(`${conflicts.length} conflicts detected`, conflicts);
    }
};
exports.throwIfConflicts = throwIfConflicts;
/**
 *
 * @param cs ComponentSet to compare
 * @param conflicts ChangeResult[] representing conflicts from SourceTracking.getConflicts
 * @returns ConflictResponse[] de-duped and formatted for json or table display
 */
const findConflictsInComponentSet = (cs, conflicts) => {
    // map do dedupe by name-type-filename
    const conflictMap = new Map();
    conflicts
        .filter(guards_1.isChangeResultWithNameAndType)
        .filter((cr) => cs.has({ fullName: cr.name, type: cr.type }))
        .forEach((cr) => {
        cr.filenames?.forEach((f) => {
            conflictMap.set(`${cr.name}#${cr.type}#${f}`, {
                state: 'Conflict',
                fullName: cr.name,
                type: cr.type,
                filePath: (0, node_path_1.resolve)(f),
            });
        });
    });
    const reformattedConflicts = Array.from(conflictMap.values());
    return reformattedConflicts;
};
exports.findConflictsInComponentSet = findConflictsInComponentSet;
const getDedupedConflictsFromChanges = ({ localChanges = [], remoteChanges = [], projectPath, forceIgnore, registry, }) => {
    const metadataKeyIndex = new Map(remoteChanges
        .filter(guards_1.isChangeResultWithNameAndType)
        .map((change) => [(0, functions_1.getMetadataKey)(change.name, change.type), change]));
    const fileNameIndex = new Map(remoteChanges.flatMap((change) => (change.filenames ?? []).map((filename) => [filename, change])));
    return (0, populateTypesAndNames_1.populateTypesAndNames)({ excludeUnresolvable: true, projectPath, forceIgnore, registry })(localChanges)
        .filter(guards_1.isChangeResultWithNameAndType)
        .flatMap((change) => {
        const metadataKey = (0, functions_1.getMetadataKey)(change.name, change.type);
        return metadataKeyIndex.has(metadataKey)
            ? // option 1: name and type match
                [metadataKeyIndex.get(metadataKey)]
            : // option 2: some of the filenames match
                (change.filenames ?? [])
                    .filter((filename) => fileNameIndex.has(filename))
                    .map((filename) => fileNameIndex.get(filename));
    });
};
exports.getDedupedConflictsFromChanges = getDedupedConflictsFromChanges;
//# sourceMappingURL=conflicts.js.map