"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureNameAndType = exports.removeIgnored = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sfError_1 = require("@salesforce/core/sfError");
const filePathGenerator_1 = require("@salesforce/source-deploy-retrieve/lib/src/utils/filePathGenerator");
const guards_1 = require("./guards");
const functions_1 = require("./functions");
const removeIgnored = (changeResults, forceIgnore, defaultPkgDir) => {
    const registry = new source_deploy_retrieve_1.RegistryAccess();
    return changeResults
        .map(exports.ensureNameAndType)
        .map((0, functions_1.changeResultToMetadataComponent)(registry))
        .filter((mc) => !(0, filePathGenerator_1.filePathsFromMetadataComponent)(mc, defaultPkgDir).some((0, functions_1.forceIgnoreDenies)(forceIgnore)))
        .map(metadataComponentToMetadataMember);
};
exports.removeIgnored = removeIgnored;
const metadataComponentToMetadataMember = (mc) => ({
    type: mc.type.name,
    fullName: mc.fullName,
});
const ensureNameAndType = (cr) => {
    if ((0, guards_1.isChangeResultWithNameAndType)(cr)) {
        return cr;
    }
    throw new sfError_1.SfError(`Change Result is missing name or type: ${JSON.stringify(cr)}`);
};
exports.ensureNameAndType = ensureNameAndType;
//# sourceMappingURL=remoteChangeIgnoring.js.map