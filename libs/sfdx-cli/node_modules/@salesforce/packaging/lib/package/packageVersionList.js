"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_ORDER_BY_FIELDS = void 0;
exports.listPackageVersions = listPackageVersions;
exports.constructQuery = constructQuery;
exports.assembleQueryParts = assembleQueryParts;
exports.constructWhere = constructWhere;
exports.validateDays = validateDays;
const core_1 = require("@salesforce/core");
const ts_types_1 = require("@salesforce/ts-types");
const packageUtils_1 = require("../utils/packageUtils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package_version_create');
const defaultFields = [
    'Id',
    'Package2Id',
    'SubscriberPackageVersionId',
    'Name',
    'Package2.Name',
    'Package2.NamespacePrefix',
    'Package2.IsOrgDependent',
    'Description',
    'Tag',
    'Branch',
    'MajorVersion',
    'MinorVersion',
    'PatchVersion',
    'BuildNumber',
    'IsReleased',
    'CreatedDate',
    'LastModifiedDate',
    'IsPasswordProtected',
    'AncestorId',
    'ValidationSkipped',
    'CreatedById',
    'ConvertedFromVersionId',
    'ReleaseVersion',
    'BuildDurationInSeconds',
    'HasMetadataRemoved',
];
const verboseFields = ['CodeCoverage', 'HasPassedCodeCoverageCheck'];
const verbose57Fields = ['Language'];
// Ensure we only include the async validation property for api version of v60.0 or higher.
const default61Fields = ['ValidatedAsync'];
exports.DEFAULT_ORDER_BY_FIELDS = 'Package2Id, Branch, MajorVersion, MinorVersion, PatchVersion, BuildNumber';
let logger;
const getLogger = () => {
    if (!logger) {
        logger = core_1.Logger.childFromRoot('packageVersionList');
    }
    return logger;
};
/**
 * Returns all the package versions that are available in the org, up to 10,000.
 * If more records are needed use the `SF_ORG_MAX_QUERY_LIMIT` env var.
 *
 * @param connection
 * @param options (optional) PackageVersionListOptions
 */
async function listPackageVersions(connection, options) {
    const query = constructQuery(Number(connection.version), options);
    return connection.autoFetchQuery(query, { tooling: true });
}
function constructQuery(connectionVersion, options) {
    // construct custom WHERE clause, if applicable
    const where = constructWhere(options);
    let queryFields = connectionVersion > 60 ? [...defaultFields, ...default61Fields] : defaultFields;
    if (options?.verbose) {
        queryFields = [...queryFields, ...verboseFields];
        if (connectionVersion >= 57) {
            queryFields = [...queryFields, ...verbose57Fields];
        }
    }
    const query = `SELECT ${queryFields.toString()} FROM Package2Version`;
    return assembleQueryParts(query, where, options?.orderBy);
}
function assembleQueryParts(select, where, orderBy) {
    // construct ORDER BY clause
    const orderByPart = `ORDER BY ${orderBy ? orderBy : exports.DEFAULT_ORDER_BY_FIELDS}`;
    const wherePart = where.length > 0 ? `WHERE ${where.join(' AND ')}` : '';
    const query = `${select} ${wherePart} ${orderByPart}`;
    getLogger().debug(query);
    return query;
}
// construct custom WHERE clause parts
function constructWhere(options) {
    const where = [];
    // filter on given package ids
    if (options?.packages?.length) {
        // remove dups
        const uniquePackageIds = [...new Set(options?.packages)];
        // validate ids
        uniquePackageIds.forEach((packageId) => {
            (0, packageUtils_1.validateId)(packageUtils_1.BY_LABEL.PACKAGE_ID, packageId);
        });
        // stash where part
        where.push(`Package2Id IN ('${uniquePackageIds.join("','")}')`);
    }
    // filter on created date, days ago: 0 for today, etc
    if ((0, ts_types_1.isNumber)(options?.createdLastDays)) {
        const createdLastDays = validateDays('createdlastdays', options?.createdLastDays);
        where.push(`CreatedDate = LAST_N_DAYS:${createdLastDays}`);
    }
    // filter on last mod date, days ago: 0 for today, etc
    if ((0, ts_types_1.isNumber)(options?.modifiedLastDays)) {
        const modifiedLastDays = validateDays('modifiedlastdays', options?.modifiedLastDays);
        where.push(`LastModifiedDate = LAST_N_DAYS:${modifiedLastDays}`);
    }
    if (options?.isReleased) {
        where.push('IsReleased = true');
    }
    if (options?.showConversionsOnly) {
        where.push('ConvertedFromVersionId != null');
    }
    if (options?.branch) {
        where.push(`Branch='${options.branch}'`);
    }
    // exclude deleted
    where.push('IsDeprecated = false');
    return where;
}
function validateDays(paramName, lastDays = -1) {
    if (lastDays < 0) {
        throw messages.createError('invalidDaysNumber', [paramName, lastDays]);
    }
    return lastDays;
}
//# sourceMappingURL=packageVersionList.js.map