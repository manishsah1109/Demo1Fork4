"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUninstallErrors = getUninstallErrors;
exports.pollUninstall = pollUninstall;
exports.uninstallPackage = uninstallPackage;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_os_1 = __importDefault(require("node:os"));
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const interfaces_1 = require("../interfaces");
const packageUtils_1 = require("../utils/packageUtils");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package_uninstall');
const pkgMessages = core_1.Messages.loadMessages('@salesforce/packaging', 'package');
async function getUninstallErrors(conn, id) {
    const errorQueryResult = await conn.tooling.query(`"SELECT Message FROM PackageVersionUninstallRequestError WHERE ParentRequest.Id = '${id}' ORDER BY Message"`);
    return errorQueryResult?.records ?? [];
}
async function pollUninstall(uninstallRequestId, conn, frequency, wait) {
    const poll = async (id) => {
        const uninstallRequest = (await conn.tooling
            .sobject('SubscriberPackageVersionUninstallRequest')
            .retrieve(id));
        switch (uninstallRequest.Status) {
            case 'Success': {
                return { completed: true, payload: uninstallRequest };
            }
            case 'InProgress':
            case 'Queued': {
                await core_1.Lifecycle.getInstance().emit(interfaces_1.PackageEvents.uninstall, {
                    ...uninstallRequest,
                });
                return { completed: false, payload: uninstallRequest };
            }
            default: {
                const err = pkgMessages.getMessage('defaultErrorMessage', [id, uninstallRequest.Id]);
                const errorMessages = await getUninstallErrors(conn, id);
                const errors = errorMessages.map((error, index) => `(${index + 1}) ${error.Message}${node_os_1.default.EOL}`);
                const combinedErrors = errors.length ? `\n=== Errors\n${errors.join(node_os_1.default.EOL)}` : '';
                throw new core_1.SfError(`${err}${combinedErrors}`, 'UNINSTALL_ERROR', [messages.getMessage('uninstallErrorAction')]);
            }
        }
    };
    const pollingClient = await core_1.PollingClient.create({
        poll: () => poll(uninstallRequestId),
        frequency,
        timeout: wait,
    });
    return pollingClient.subscribe();
}
async function uninstallPackage(id, conn, frequency = kit_1.Duration.seconds(0), wait = kit_1.Duration.seconds(0)) {
    try {
        const uninstallRequest = await conn.tooling.sobject('SubscriberPackageVersionUninstallRequest').create({
            SubscriberPackageVersionId: id,
        });
        if (uninstallRequest.success) {
            if (wait.seconds === 0) {
                return (await conn.tooling
                    .sobject('SubscriberPackageVersionUninstallRequest')
                    .retrieve(uninstallRequest.id));
            }
            else {
                return await pollUninstall(uninstallRequest.id, conn, frequency, wait);
            }
        }
        throw (0, packageUtils_1.combineSaveErrors)('SubscriberPackageVersionUninstallRequest', 'create', uninstallRequest.errors);
    }
    catch (err) {
        if (err instanceof Error) {
            throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
        }
        throw err;
    }
}
//# sourceMappingURL=packageUninstall.js.map