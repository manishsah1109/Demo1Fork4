"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = exports.Package2Fields = void 0;
const core_1 = require("@salesforce/core");
const packageUtils_1 = require("../utils/packageUtils");
const packageCreate_1 = require("./packageCreate");
const packageConvert_1 = require("./packageConvert");
const packageVersionRetrieve_1 = require("./packageVersionRetrieve");
const packageVersionList_1 = require("./packageVersionList");
const packageDelete_1 = require("./packageDelete");
const packageAncestry_1 = require("./packageAncestry");
const packagePrefixes = {
    PackageId: '0Ho',
    SubscriberPackageVersionId: '04t',
    PackageInstallRequestId: '0Hf',
    PackageUninstallRequestId: '06y',
};
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/packaging', 'package');
exports.Package2Fields = [
    'Id',
    'IsDeleted',
    'CreatedDate',
    'CreatedById',
    'LastModifiedDate',
    'LastModifiedById',
    'SystemModstamp',
    'SubscriberPackageId',
    'Name',
    'Description',
    'NamespacePrefix',
    'ContainerOptions',
    'IsDeprecated',
    'IsOrgDependent',
    'ConvertedFromPackageId',
    'PackageErrorUsername',
    'AppAnalyticsEnabled',
];
/**
 * Provides the ability to list, create, update, delete, convert, and get version
 * ancestry for a 2nd generation package.
 *
 * **Examples**
 *
 * Create a new instance and get the ID (0Ho):
 *
 * `const id = new Package({connection, project, packageOrAliasId}).getId();`
 *
 * Create a new package in the org:
 *
 * `const myPkg = await Package.create(connection, project, options);`
 *
 * List all packages in the org:
 *
 * `const pkgList = await Package.list(connection);`
 */
class Package {
    options;
    packageId;
    packageData;
    constructor(options) {
        this.options = options;
        let packageId = this.options.packageAliasOrId;
        if (!packageId.startsWith(packagePrefixes.PackageId)) {
            packageId = this.options.project
                ? this.options.project.getPackageIdFromAlias(this.options.packageAliasOrId) ?? this.options.packageAliasOrId
                : this.options.packageAliasOrId;
            if (packageId === this.options.packageAliasOrId) {
                throw messages.createError('packageAliasNotFound', [this.options.packageAliasOrId]);
            }
        }
        if (packageId.startsWith(packagePrefixes.PackageId)) {
            this.packageId = packageId;
        }
        else {
            throw messages.createError('invalidPackageId', [this.options.packageAliasOrId, packagePrefixes.PackageId]);
        }
    }
    /**
     * Create a new package.
     *
     * @param connection - instance of Connection
     * @param project - instance of SfProject
     * @param options - options for creating a package - see PackageCreateOptions
     * @returns Package
     */
    static async create(connection, project, options) {
        return (0, packageCreate_1.createPackage)(connection, project, options);
    }
    /**
     * Returns all the packages that are available in the org, up to 10,000. If more records are
     * needed use the `SF_ORG_MAX_QUERY_LIMIT` env var.
     *
     * @param connection
     */
    static async list(connection) {
        const query = `select ${this.getPackage2Fields(connection).toString()} from Package2 ORDER BY NamespacePrefix, Name`;
        return (await connection.autoFetchQuery(query, { tooling: true }))?.records;
    }
    /**
     * Returns the package versions in the org.
     * See {@link PackageVersionListOptions} for list options
     *
     * @param connection - connection to the org
     * @param project - instance of SfProject
     * @param options - see {@link PackageVersionListOptions}
     */
    static async listVersions(connection, project, options) {
        // resolve/verify packages
        const packages = options?.packages?.map((pkg) => {
            const id = project ? project.getPackageIdFromAlias(pkg) ?? pkg : pkg;
            // validate ID
            if (id.startsWith('0Ho')) {
                (0, packageUtils_1.validateId)(packageUtils_1.BY_LABEL.PACKAGE_ID, id);
                return id;
            }
            else {
                throw messages.createError('invalidPackageId', [id, '0Ho']);
            }
        });
        const opts = options ?? {};
        opts.packages = packages ?? [];
        return (await (0, packageVersionList_1.listPackageVersions)(connection, opts)).records;
    }
    /**
     * create a PackageAncestry instance
     *
     * @param packageId to get version information for
     * @param project SfProject instance
     * @param connection Hub Org Connection
     */
    static async getAncestry(packageId, project, connection) {
        return packageAncestry_1.PackageAncestry.create({
            packageId,
            project,
            connection,
        });
    }
    /**
     * Convert a 1st generation package to a 2nd generation package.
     * See {@link ConvertPackageOptions} for conversion options.
     *
     * @param pkgId the 1GP package ID (033) of the package to convert
     * @param connection
     * @param options {@link ConvertPackageOptions}
     * @param project
     */
    static async convert(pkgId, connection, options, project) {
        return (0, packageConvert_1.convertPackage)(pkgId, connection, options, project);
    }
    /**
     * Download the metadata files for a previously published package version, convert them to source format, and put them into a new project folder within the sfdx project.
     *
     * @param project
     * @param options {@link PackageVersionMetadataDownloadOptions}
     * @param connection
     * @returns
     */
    static async downloadPackageVersionMetadata(project, options, connection) {
        return (0, packageVersionRetrieve_1.retrievePackageVersionMetadata)(project, options, connection);
    }
    static getPackage2Fields(connection) {
        const apiVersion = connection.getApiVersion();
        return exports.Package2Fields.filter((field) => (apiVersion >= '59.0' ? true : field !== 'AppAnalyticsEnabled'));
    }
    /**
     * Returns the package ID of the package.
     *
     * @returns {string} package ID (0Ho)
     */
    getId() {
        return this.packageId;
    }
    /**
     * Returns the package type of the package.
     *
     * @returns {Promise<PackageType>}
     */
    async getType() {
        return (await this.getPackageData())?.ContainerOptions;
    }
    /**
     * Returns the list of package versions for the package.
     * See {@link PackageVersionListOptions} for list options
     *
     * @param options
     * @returns {Promise<PackageVersionListResult[]>}
     */
    async getPackageVersions(options) {
        const packageOptions = {
            packages: [this.packageId],
        };
        return Package.listVersions(this.options.connection, this.options.project, {
            ...packageOptions,
            ...options,
        });
    }
    /**
     * Deletes the package.
     *
     */
    async delete() {
        return (0, packageDelete_1.deletePackage)(this.getId(), this.options.project, this.options.connection, false);
    }
    /**
     * Un-Deletes the package.
     *
     */
    async undelete() {
        return (0, packageDelete_1.deletePackage)(this.getId(), this.options.project, this.options.connection, true);
    }
    /**
     * Updates the package using the values defined in the options.
     * See {@link PackageUpdateOptions} for update options.
     *
     * @param options
     */
    async update(options) {
        try {
            // filter out any undefined values and their keys
            const opts = Object.fromEntries(Object.entries(options).filter(([, value]) => value !== undefined));
            if (opts.AppAnalyticsEnabled !== undefined && this.options.connection.getApiVersion() < '59.0') {
                throw messages.createError('appAnalyticsEnabledApiPriorTo59Error');
            }
            const result = await this.options.connection.tooling.update('Package2', opts);
            if (!result.success) {
                throw new core_1.SfError(result.errors.join(', '));
            }
            return result;
        }
        catch (err) {
            if (err instanceof Error) {
                throw (0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(err));
            }
            throw err;
        }
    }
    /**
     * Returns the package data for the package.
     *
     * @param force force a refresh of the package data
     */
    async getPackageData(force = false) {
        if (!this.packageData ?? force) {
            this.packageData = (await this.options.connection.tooling
                .sobject('Package2')
                .retrieve(this.packageId));
            if (!this.packageData) {
                throw messages.createError('packageNotFound', [this.packageId]);
            }
        }
        return this.packageData;
    }
}
exports.Package = Package;
//# sourceMappingURL=package.js.map