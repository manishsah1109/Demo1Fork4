"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPackageRequestFromContext = createPackageRequestFromContext;
exports.createPackageDirEntry = createPackageDirEntry;
exports.createPackage = createPackage;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const project_1 = require("@salesforce/core/project");
const pkgUtils = __importStar(require("../utils/packageUtils"));
const packageUtils_1 = require("../utils/packageUtils");
function createPackageRequestFromContext(project, options) {
    const namespace = options.noNamespace ? '' : project.getSfProjectJson().getContents().namespace ?? '';
    return {
        Name: options.name,
        Description: options.description,
        NamespacePrefix: namespace,
        ContainerOptions: options.packageType,
        IsOrgDependent: options.orgDependent,
        PackageErrorUsername: options.errorNotificationUsername,
    };
}
/**
 * Create packageDirectory json entry for this package that can be written to sfdx-project.json
 *
 * @param project
 * @param options - package create options
 * @private
 */
function createPackageDirEntry(project, options) {
    const packageDirs = project.getSfProjectJson().getContents().packageDirectories ?? [];
    return {
        versionName: 'ver 0.1',
        versionNumber: '0.1.0.NEXT',
        ...(packageDirs
            .filter((pd) => pd.path === options.path && !(0, project_1.isPackagingDirectory)(pd))
            .find((pd) => !('id' in pd)) ?? {
            // no match - create a new one
            path: options.path,
            default: packageDirs.length === 0 ? true : !packageDirs.some((pd) => pd.default === true),
        }),
        package: options.name,
        versionDescription: options.description,
    };
}
async function createPackage(connection, project, options) {
    const cleanOptions = sanitizePackageCreateOptions(options);
    const request = createPackageRequestFromContext(project, cleanOptions);
    const createResult = await connection.tooling
        .sobject('Package2')
        .create(request)
        .catch((err) => {
        const error = err instanceof Error ? err : new Error(typeof err === 'string' ? err : 'Unknown error');
        throw core_1.SfError.wrap((0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(error)));
    });
    if (!createResult.success) {
        throw pkgUtils.combineSaveErrors('Package2', 'create', createResult.errors);
    }
    if (!kit_1.env.getBoolean('SF_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_CREATE')) {
        const packageDirectory = createPackageDirEntry(project, cleanOptions);
        project.getSfProjectJson().addPackageDirectory(packageDirectory);
        project.getSfProjectJson().addPackageAlias(cleanOptions.name, createResult.id);
        await project.getSfProjectJson().write();
    }
    return { Id: createResult.id };
}
/** strip trailing slash from path param */
const sanitizePackageCreateOptions = (options) => ({
    ...options,
    path: options.path.replace(/\/$/, ''),
});
//# sourceMappingURL=packageCreate.js.map