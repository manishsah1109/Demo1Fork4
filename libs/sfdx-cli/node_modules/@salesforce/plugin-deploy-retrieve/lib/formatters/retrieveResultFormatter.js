/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import path from 'node:path';
import { SfProject } from '@salesforce/core';
import { ensureArray } from '@salesforce/kit';
import { isSdrSuccess } from '../utils/types.js';
import { tableHeader, getFileResponseSuccessProps, fileResponseSortFn, makePathRelative } from '../utils/output.js';
export class RetrieveResultFormatter {
    ux;
    result;
    packageNames;
    files;
    constructor(ux, result, packageNames = [], deleteResponses = []) {
        this.ux = ux;
        this.result = result;
        this.packageNames = packageNames;
        this.files = (this.result.getFileResponses() ?? []).concat(deleteResponses);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getJson() {
        const { zipFile, ...responseWithoutZip } = this.result.response;
        return { ...responseWithoutZip, files: this.files };
    }
    async display() {
        this.displaySuccesses();
        await this.displayPackages();
    }
    displaySuccesses() {
        const successes = this.files
            .filter(isSdrSuccess)
            .map(makePathRelative)
            .sort(fileResponseSortFn)
            .map(getFileResponseSuccessProps);
        if (!successes.length) {
            // a retrieve happened, but nothing was retrieved
            if (this.result.response.status) {
                this.ux.warn('Nothing retrieved');
            }
            else {
                // a retrieve didn't happen, probably because everything was ignored or there were no remote changes to retrieve
                this.ux.log('Nothing retrieved');
            }
        }
        else {
            const columns = {
                state: { header: 'State' },
                fullName: { header: 'Name' },
                type: { header: 'Type' },
                filePath: { header: 'Path' },
            };
            const options = { title: tableHeader('Retrieved Source'), 'no-truncate': true };
            this.ux.log();
            this.ux.table(successes, columns, options);
        }
        const warnings = getWarnings(this.result);
        if (warnings.length) {
            this.ux.log();
            this.ux.table(warnings, { fileName: { header: 'File' }, problem: { header: 'Problem' } }, { 'no-truncate': true, title: tableHeader('Warnings') });
        }
    }
    async displayPackages() {
        const packages = await this.getPackages();
        if (packages?.length) {
            const columns = {
                name: { header: 'Package Name' },
                fullPath: { header: 'Converted Location' },
            };
            const options = { title: tableHeader('Retrieved Packages'), 'no-truncate': true };
            this.ux.log();
            this.ux.warn('Metadata from retrieved packages is meant for your reference only, not development.');
            this.ux.table(packages, columns, options);
        }
    }
    async getPackages() {
        const projectPath = await SfProject.resolveProjectPath();
        return this.packageNames.map((name) => {
            const packagePath = path.join(projectPath, name);
            return { name, path: packagePath, fullPath: path.resolve(packagePath) };
        });
    }
}
const getWarnings = (result) => ensureArray(result?.response?.messages ?? []);
//# sourceMappingURL=retrieveResultFormatter.js.map