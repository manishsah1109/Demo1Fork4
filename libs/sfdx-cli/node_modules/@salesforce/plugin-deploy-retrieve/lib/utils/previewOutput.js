/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { isAbsolute, relative, resolve } from 'node:path';
import { Ux } from '@salesforce/sf-plugins-core';
import { StandardColors } from '@salesforce/sf-plugins-core';
import { Messages } from '@salesforce/core';
import { DestructiveChangesType, MetadataResolver, VirtualTreeContainer, RegistryAccess, } from '@salesforce/source-deploy-retrieve';
import { filePathsFromMetadataComponent } from '@salesforce/source-deploy-retrieve/lib/src/utils/filePathGenerator.js';
import { isSourceComponentWithXml } from './types.js';
const ux = new Ux();
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'previewMessages');
const ensureAbsolutePath = (f) => (isAbsolute(f) ? f : resolve(f));
// borrowed from STL populateFilesPaths.
// TODO: this goes in SDR maybe?
const resolvePaths = (filenames, registry) => {
    // component set generated from the filenames on all local changes
    const resolver = new MetadataResolver(registry, VirtualTreeContainer.fromFilePaths(filenames), false);
    const sourceComponents = filenames
        .flatMap((filename) => {
        try {
            return resolver.getComponentsFromPath(filename);
        }
        catch (e) {
            // resolver will do logging before throw we don't do it here
            return [];
        }
    })
        .filter(isSourceComponentWithXml)
        .map((sc) => ({ fullName: sc.fullName, type: sc.type.name, path: ensureAbsolutePath(sc.xml) }));
    // dedupe by xml path
    return Array.from(new Map(sourceComponents.map((sc) => [sc.path, sc])).values());
};
const calculateDeployOperation = (destructiveChangesType) => {
    switch (destructiveChangesType) {
        case DestructiveChangesType.POST:
            return 'deletePost';
        case DestructiveChangesType.PRE:
            return 'deletePre';
        default:
            return 'deploy';
    }
};
const getNonIgnoredConflicts = (files) => files.filter((f) => f.conflict && !f.ignored);
const willGo = (previewFile) => !previewFile.conflict && !previewFile.ignored;
const getWillDeploy = (files) => files.filter(willGo).filter((f) => f.operation === 'deploy');
const getWillRetrieve = (files) => files.filter(willGo).filter((f) => f.operation === 'retrieve');
const getWillDelete = (files) => files.filter(willGo).filter((f) => f.operation && ['deletePre', 'deletePost'].includes(f.operation));
// relative paths are easier on tables
const columns = { type: {}, fullName: {}, projectRelativePath: { header: 'Path' } };
const makeKey = ({ type, fullName }) => `${type.name}#${fullName}`;
export const compileResults = ({ componentSet, projectPath, filesWithConflicts, forceIgnore, baseOperation, remoteDeletes, }) => {
    // when we iterate all the componentSet,
    // this map makes it easy to get the source-backed local components
    const sourceBackedComponents = new Map(componentSet.getSourceComponents().map((sc) => [makeKey({ type: sc.type, fullName: sc.fullName }), sc]));
    const sourceComponentToPreviewFile = (c) => ({
        type: c.type.name,
        fullName: c.fullName,
        conflict: [c.xml, c.content].some((v) => v && filesWithConflicts.has(v)),
        // There should not be anything in forceignore returned by the componentSet
        ignored: [c.xml, c.content].some((v) => v && forceIgnore.denies(v)),
        // properties to return if we have an xml path
        ...getPaths(c),
    });
    /** resolve absolute and relative paths for a source component, with a preference for the xml file, but able to use the content file as backup */
    const getPaths = (c) => {
        const someFile = c.xml ?? c.content;
        if (someFile) {
            return {
                path: isAbsolute(someFile) ? someFile : resolve(someFile),
                // for cleaner output
                projectRelativePath: relative(projectPath, someFile),
            };
        }
        return {};
    };
    const actionableFiles = componentSet
        .filter((f) => f.fullName !== '*')
        .toArray()
        .map((c) => sourceBackedComponents.get(makeKey(c)) ?? c)
        .map((cmp) => {
        const maybeSourceBackedComponent = sourceBackedComponents.get(makeKey(cmp)) ?? cmp;
        if ('xml' in maybeSourceBackedComponent) {
            // source backed components exist locally
            return {
                ...sourceComponentToPreviewFile(maybeSourceBackedComponent),
                operation: baseOperation === 'deploy'
                    ? calculateDeployOperation(maybeSourceBackedComponent.getDestructiveChangesType())
                    : baseOperation,
            };
        }
        else {
            return {
                type: maybeSourceBackedComponent.type.name,
                fullName: maybeSourceBackedComponent.fullName,
                // if it doesn't exist locally, it can't be a conflict
                conflict: false,
                operation: baseOperation,
                // we have to calculate the "potential filename" to know if a remote retrieve would be ignored
                ignored: filePathsFromMetadataComponent(maybeSourceBackedComponent).some((p) => forceIgnore.denies(p)),
            };
        }
    })
        // remote deletes are not in the componentSet
        .concat((remoteDeletes ?? []).map((c) => ({
        ...sourceComponentToPreviewFile(c),
        operation: 'deletePre',
    })));
    // Source backed components won't appear in the ComponentSet if ignored
    const ignoredSourceComponents = resolvePaths([...(componentSet.forceIgnoredPaths ?? [])], new RegistryAccess(undefined, projectPath)).map((resolved) => ({
        ...resolved,
        ...(resolved.path ? { projectRelativePath: relative(projectPath, resolved.path) } : {}),
        conflict: false,
        ignored: true,
    }));
    return {
        ignored: ignoredSourceComponents.concat(actionableFiles.filter((f) => f.ignored)),
        toDeploy: getWillDeploy(actionableFiles),
        toRetrieve: getWillRetrieve(actionableFiles),
        toDelete: getWillDelete(actionableFiles),
        conflicts: getNonIgnoredConflicts(actionableFiles),
    };
};
const printDeployTable = (files) => {
    ux.log();
    if (files.length === 0) {
        ux.log(StandardColors.info(messages.getMessage('deploy.none')));
    }
    else {
        // not using table title property to avoid all the ASCII art
        ux.log(StandardColors.success(messages.getMessage('deploy.header', [files.length])));
        ux.table(files, columns);
    }
};
const printRetrieveTable = (files) => {
    ux.log();
    if (files.length === 0) {
        ux.log(StandardColors.info(messages.getMessage('retrieve.none')));
    }
    else {
        // not using table title property to avoid all the ASCII art
        ux.log(StandardColors.success(messages.getMessage('retrieve.header', [files.length])));
        ux.table(files, columns);
    }
};
const printDeleteTable = (files) => {
    ux.log();
    if (files.length === 0) {
        ux.log(StandardColors.info(messages.getMessage('delete.none')));
    }
    else {
        ux.log(StandardColors.warning(messages.getMessage('delete.header', [files.length])));
        ux.table(files, columns);
    }
};
const printConflictsTable = (files) => {
    ux.log();
    if (files.length === 0) {
        ux.log(StandardColors.info(messages.getMessage('conflicts.none')));
    }
    else {
        ux.log(StandardColors.error(messages.getMessage('conflicts.header', [files.length])));
        ux.table(files, columns, { sort: 'path' });
    }
};
const printIgnoredTable = (files, baseOperation) => {
    ux.log();
    if (files.length === 0) {
        ux.log(StandardColors.info(messages.getMessage('ignored.none')));
    }
    else {
        ux.log(StandardColors.info(messages.getMessage('ignored.header', [files.length, baseOperation])));
        ux.table(files, columns, { sort: 'path' });
    }
};
export const printTables = (result, baseOperation, concise = false) => {
    printConflictsTable(result.conflicts);
    printDeleteTable(result.toDelete);
    if (baseOperation === 'deploy') {
        printDeployTable(result.toDeploy);
    }
    else if (baseOperation === 'retrieve') {
        printRetrieveTable(result.toRetrieve);
    }
    if (!concise) {
        printIgnoredTable(result.ignored, baseOperation);
    }
};
export const getConflictFiles = async (stl, ignore = false) => !stl || ignore
    ? new Set()
    : new Set((await stl.getConflicts()).flatMap((conflict) => (conflict.filenames ?? []).map((f) => resolve(f))));
//# sourceMappingURL=previewOutput.js.map