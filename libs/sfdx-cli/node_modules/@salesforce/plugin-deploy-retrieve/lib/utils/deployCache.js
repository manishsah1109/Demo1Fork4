/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Global, TTLConfig } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
import { cacheMessages } from './deploy.js';
import { maybeDestroyManifest } from './manifestCache.js';
export class DeployCache extends TTLConfig {
    static getFileName() {
        return 'deploy-cache.json';
    }
    static getDefaultOptions() {
        return {
            isGlobal: true,
            isState: true,
            filename: DeployCache.getFileName(),
            stateFolder: Global.SF_STATE_FOLDER,
            ttl: Duration.days(3),
        };
    }
    /**
     *
     * @param key jobId
     * @param value a DeployOptions object (wait is a duration, can use non-manifest options)
     * @param manifestFilePath the path to the manifest file generated by the deploy
     */
    static async set(key, value) {
        const cache = await DeployCache.create();
        // remove properties we won't cache or that are not primitives
        const { 'metadata-dir': mdDir, 'source-dir': sourceDir, wait, ...cleanValue } = value;
        cache.set(key, { ...cleanValue, wait: wait?.minutes ?? 33, isMdapi: Boolean(mdDir) });
        await cache.write();
    }
    static async unset(key) {
        const cache = await DeployCache.create();
        cache.unset(ensure18(key, cache));
        await Promise.all([cache.write(), maybeDestroyManifest(key)]);
    }
    static async update(key, obj) {
        const cache = await DeployCache.create();
        cache.update(ensure18(key, cache), obj);
        await cache.write();
    }
    update(key, obj) {
        super.update(ensure18(key, this), obj);
    }
    /** will return an 18 character ID if throwOnNotFound is true (because the cache can be used to shift 15 to 18) */
    resolveLatest(useMostRecent, key, throwOnNotFound) {
        const resolvedKey = useMostRecent ? this.getLatestKey() : key;
        if (!resolvedKey)
            throw cacheMessages.createError('error.NoRecentJobId');
        const match = this.maybeGet(resolvedKey);
        if (throwOnNotFound === true && !match) {
            throw cacheMessages.createError('error.NoMatchingJobId', [resolvedKey]);
        }
        return throwOnNotFound ? ensure18(resolvedKey, this) : resolvedKey;
    }
    /**
     * @deprecated.  Use maybeGet to handle both 15 and 18 char IDs
     * returns 18-char ID unmodified, regardless of whether it's in cache or not
     * returns 15-char ID if it matches a key in the cache, otherwise throws
     */
    resolveLongId(jobId) {
        return ensure18(jobId, this);
    }
    /**
     *
     * @deprecated.  Use maybeGet because the typings are wrong in sfdx-core
     */
    get(jobId) {
        return super.get(this.resolveLongId(jobId));
    }
    /**
     * works with 18 and 15-character IDs.
     * Prefer 18 as that's how the cache is keyed.
     * Returns undefined if no match is found.
     */
    maybeGet(jobId) {
        if (jobId.length === 18) {
            return super.get(jobId);
        }
        if (jobId.length === 15) {
            const match = this.keys().find((k) => k.startsWith(jobId));
            return match ? super.get(match) : undefined;
        }
        throw cacheMessages.createError('error.InvalidJobId', [jobId]);
    }
}
/**
 * if the jobId is 15 characters, use the cache to convert to 18
 * will throw if the value is not in the cache
 */
const ensure18 = (jobId, cache) => {
    if (jobId.length === 18) {
        return jobId;
    }
    else if (jobId.length === 15) {
        const match = cache.keys().find((k) => k.startsWith(jobId));
        if (match) {
            return match;
        }
        throw cacheMessages.createError('error.NoMatchingJobId', [jobId]);
    }
    else {
        throw cacheMessages.createError('error.InvalidJobId', [jobId]);
    }
};
//# sourceMappingURL=deployCache.js.map