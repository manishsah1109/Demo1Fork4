{
  "commands": {
    "project:convert:mdapi": {
      "aliases": [
        "force:mdapi:convert"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "To use Salesforce CLI to work with components that you retrieved via Metadata API, first convert your files from the metadata format to the source format using this command.\n\nTo convert files from the source format back to the metadata format, run \"sf project convert source\".\n\nTo convert multiple metadata components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.",
      "examples": [
        "Convert metadata formatted files in the specified directory into source formatted files; writes converted files to your default package directory:\n$ <%= config.bin %> <%= command.id %> --root-dir path/to/metadata",
        "Similar to previous example, but writes converted files to the specified output directory:\n$ <%= config.bin %> <%= command.id %> --root-dir path/to/metadata --output-dir path/to/outputdir"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "aliases": [
            "apiversion"
          ],
          "deprecateAliases": true,
          "description": "Override the api version used for api requests made by this command",
          "name": "api-version",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "loglevel": {
          "deprecated": {
            "message": "The loglevel flag is no longer in use on this command. You may use it without error, but it will be ignored.\nSet the log level using the `SFDX_LOG_LEVEL` environment variable."
          },
          "hidden": true,
          "name": "loglevel",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "root-dir": {
          "aliases": [
            "rootdir"
          ],
          "char": "r",
          "deprecateAliases": true,
          "name": "root-dir",
          "required": true,
          "summary": "Root directory that contains the Metadata API–formatted metadata.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "output-dir": {
          "aliases": [
            "outputdir"
          ],
          "char": "d",
          "deprecateAliases": true,
          "name": "output-dir",
          "summary": "Directory to store your files in after they’re converted to source format; can be an absolute or relative path.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "manifest": {
          "char": "x",
          "description": "If you specify this parameter, don’t specify --metadata or --source-dir.",
          "name": "manifest",
          "summary": "File path to manifest (package.xml) of metadata types to convert.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "metadata-dir": {
          "aliases": [
            "metadatapath"
          ],
          "char": "p",
          "deprecateAliases": true,
          "description": "The supplied paths can be to a single file (in which case the operation is applied to only one file) or to a folder (in which case the operation is applied to all metadata types in the directory and its sub-directories).\n\nIf you specify this flag, don’t specify --manifest or --metadata. If the comma-separated list you’re supplying contains spaces, enclose the entire comma-separated list in one set of double quotes.",
          "exclusive": [
            "manifest",
            "metadata"
          ],
          "name": "metadata-dir",
          "summary": "Root of directory or zip file of metadata formatted files to convert.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "exclusive": [
            "manifest",
            "metadatapath"
          ],
          "name": "metadata",
          "summary": "Metadata component names to convert.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        }
      },
      "hasDynamicHelp": false,
      "hiddenAliases": [],
      "id": "project:convert:mdapi",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Convert metadata retrieved via Metadata API into the source format used in Salesforce DX projects.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "convert",
        "mdapi.js"
      ],
      "aliasPermutations": [
        "force:mdapi:convert",
        "mdapi:force:convert",
        "mdapi:convert:force",
        "force:convert:mdapi",
        "convert:force:mdapi",
        "convert:mdapi:force"
      ],
      "permutations": [
        "project:convert:mdapi",
        "convert:project:mdapi",
        "convert:mdapi:project",
        "project:mdapi:convert",
        "mdapi:project:convert",
        "mdapi:convert:project"
      ]
    },
    "project:convert:source-behavior": {
      "aliases": [],
      "args": {},
      "description": "Specifically, this command updates the \"sourceBehaviorOption\" option in the \"sfdx-project.json\" file and then converts the associated local source files in your project as needed.\n\nFor example, run this command with the \"--behavior decomposePermissionSetBeta\" flag to start decomposing permission sets when you deploy or retrieve them. Decomposing means breaking up the monolithic metadata API format XML file that corresponds to a metadata component into smaller XML files and directories based on its subtypes. Permission sets are not decomposed by default; you must opt-in to start decomposing them by using this command. When the command finishes, your \"sfdx-project.json\" file is updated to always decompose permission sets, and the existing permission set files in your local package directories are converted into the new decomposed format. You run this command only once for a given behavior change.\n\nFor more information about the possible values for the --behavior flag, see the \"sourceBehaviorOptions\" section in the https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_config.htm topic.",
      "examples": [
        "Update your Salesforce DX project to decompose custom permission sets:\n<%= config.bin %> <%= command.id %> --behavior decomposePermissionSetBeta",
        "Display what the command would do, but don't change any existing files:\n<%= config.bin %> <%= command.id %> --behavior decomposePermissionSetBeta --dry-run",
        "Keep the temporary directory that contains the interim metadata API formatted files:\n<%= config.bin %> <%= command.id %> --behavior decomposePermissionSetBeta --dry-run --preserve-temp-dir"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "behavior": {
          "char": "b",
          "name": "behavior",
          "required": true,
          "summary": "Behavior to enable; the values correspond to the possible values of the \"sourceBehaviorOption\" option in the \"sfdx-project.json\" file.",
          "hasDynamicHelp": false,
          "multiple": false,
          "options": [
            "decomposeCustomLabelsBeta2",
            "decomposeCustomLabelsBeta",
            "decomposePermissionSetBeta",
            "decomposeSharingRulesBeta",
            "decomposeWorkflowBeta"
          ],
          "type": "option"
        },
        "dry-run": {
          "name": "dry-run",
          "summary": "Display what the command would do, but don't make any actual changes.",
          "allowNo": false,
          "type": "boolean"
        },
        "preserve-temp-dir": {
          "name": "preserve-temp-dir",
          "summary": "Don't delete the metadata API format temporary directory that this command creates. Useful for debugging.",
          "allowNo": false,
          "type": "boolean"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "summary": "Username or alias of the target org.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:convert:source-behavior",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "state": "beta",
      "strict": true,
      "summary": "Enable a behavior of your project source files, and then update your Salesforce DX project to implement the behavior.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "convert",
        "source-behavior.js"
      ],
      "aliasPermutations": [],
      "permutations": [
        "project:convert:source-behavior",
        "convert:project:source-behavior",
        "convert:source-behavior:project",
        "project:source-behavior:convert",
        "source-behavior:project:convert",
        "source-behavior:convert:project"
      ]
    },
    "project:convert:source": {
      "aliases": [
        "force:source:convert"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "To convert source-formatted files into the metadata format, so that you can deploy them using Metadata API, run this command. Then deploy the metadata using \"<%= config.bin %> project deploy\".\n\nTo convert Metadata API–formatted files into the source format, run \"<%= config.bin %> project convert mdapi\".\n\nTo specify a package name that includes spaces, enclose the name in single quotes.\n\nTo convert multiple components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.",
      "examples": [
        "Convert source-formatted files in the specified directory into metadata-formatted files; writes converted files into a new directory:\n$ <%= config.bin %> <%= command.id %> --root-dir path/to/source",
        "Similar to previous example, but writes converted files to the specified output directory and associates the files with the specified package:\n$ <%= config.bin %> <%= command.id %> --root-dir path/to/source --output-dir path/to/outputdir --package-name 'My Package'"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "aliases": [
            "apiversion"
          ],
          "deprecateAliases": true,
          "description": "Override the api version used for api requests made by this command",
          "name": "api-version",
          "summary": "API Version to use in the generated project's manifest. By default, will use the version from sfdx-project.json",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "loglevel": {
          "deprecated": {
            "message": "The loglevel flag is no longer in use on this command. You may use it without error, but it will be ignored.\nSet the log level using the `SFDX_LOG_LEVEL` environment variable."
          },
          "hidden": true,
          "name": "loglevel",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "root-dir": {
          "aliases": [
            "rootdir"
          ],
          "char": "r",
          "deprecateAliases": true,
          "name": "root-dir",
          "summary": "Source directory other than the default package to convert.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "output-dir": {
          "aliases": [
            "outputdir"
          ],
          "char": "d",
          "deprecateAliases": true,
          "name": "output-dir",
          "summary": "Output directory to store the Metadata API–formatted files in.",
          "default": "metadataPackage_1724785521500",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "package-name": {
          "aliases": [
            "packagename"
          ],
          "char": "n",
          "deprecateAliases": true,
          "name": "package-name",
          "summary": "Name of the package to associate with the metadata-formatted files.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "manifest": {
          "char": "x",
          "description": "If you specify this parameter, don’t specify --metadata or --source-dir.",
          "name": "manifest",
          "summary": "Path to the manifest (package.xml) file that specifies the metadata types to convert.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "source-dir": {
          "aliases": [
            "sourcepath"
          ],
          "char": "p",
          "deprecateAliases": true,
          "description": "The supplied paths can be to a single file (in which case the operation is applied to only one file) or to a folder (in which case the operation is applied to all metadata types in the directory and its sub-directories).\n\nIf you specify this parameter, don’t specify --manifest or --metadata.",
          "exclusive": [
            "manifest",
            "metadata"
          ],
          "name": "source-dir",
          "summary": "Paths to the local source files to convert.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "exclusive": [
            "manifest",
            "sourcepath"
          ],
          "name": "metadata",
          "summary": "Metadata component names to convert.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        }
      },
      "hasDynamicHelp": false,
      "hiddenAliases": [],
      "id": "project:convert:source",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Convert source-formatted files into metadata that you can deploy using Metadata API.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "convert",
        "source.js"
      ],
      "aliasPermutations": [
        "force:source:convert",
        "source:force:convert",
        "source:convert:force",
        "force:convert:source",
        "convert:force:source",
        "convert:source:force"
      ],
      "permutations": [
        "project:convert:source",
        "convert:project:source",
        "convert:source:project",
        "project:source:convert",
        "source:project:convert",
        "source:convert:project"
      ]
    },
    "project:delete:source": {
      "aliases": [
        "force:source:delete"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Use this command to delete components from orgs that don’t have source tracking. To remove deleted items from orgs that have source tracking enabled, \"<%= config.bin %> project deploy start\".\n\nWhen you run this command, both the local source file and the metadata component in the org are deleted.\n\nTo delete multiple metadata components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.",
      "examples": [
        "Delete all local Apex source files and all Apex classes from the org with alias \"my-scratch\":\n<%= config.bin %> <%= command.id %> --metadata ApexClass --target-org my-scratch",
        "Delete a specific Apex class and a Profile that has a space in it from your default org; don't prompt for confirmation:\n<%= config.bin %> <%= command.id %> --metadata ApexClass:MyFabulousApexClass --metadata \"Profile: My Profile\" --no-prompt",
        "Run the tests that aren’t in any managed packages as part of the deletion; if the delete succeeds, and the org has source-tracking enabled, update the source tracking information:\n<%= config.bin %> <%= command.id %> --metadata ApexClass --test-level RunLocalTests --track-source",
        "Delete the Apex source files in a directory and the corresponding components from your default org:\n<%= config.bin %> <%= command.id %> --source-dir force-app/main/default/classes"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "aliases": [
            "apiversion"
          ],
          "deprecateAliases": true,
          "description": "Override the api version used for api requests made by this command",
          "name": "api-version",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "loglevel": {
          "deprecated": {
            "message": "The loglevel flag is no longer in use on this command. You may use it without error, but it will be ignored.\nSet the log level using the `SFDX_LOG_LEVEL` environment variable."
          },
          "hidden": true,
          "name": "loglevel",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "aliases": [
            "targetusername",
            "u"
          ],
          "char": "o",
          "deprecateAliases": true,
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "check-only": {
          "aliases": [
            "checkonly"
          ],
          "char": "c",
          "deprecateAliases": true,
          "description": "IMPORTANT: Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain terms to avoid any effect on customer implementations.\n\nValidates the deleted metadata and runs all Apex tests, but prevents the deletion from being saved to the org.\n\nIf you change a field type from Master-Detail to Lookup or vice versa, that change isn’t supported when using the --check-only parameter to test a deletion (validation). This kind of change isn’t supported for test deletions to avoid the risk of data loss or corruption. If a change that isn’t supported for test deletions is included in a deletion package, the test deletion fails and issues an error.\n\nIf your deletion package changes a field type from Master-Detail to Lookup or vice versa, you can still validate the changes prior to deploying to Production by performing a full deletion to another test Sandbox. A full deletion includes a validation of the changes as part of the deletion process.\n\nNote: A Metadata API deletion that includes Master-Detail relationships deletes all detail records in the Recycle Bin in the following cases.\n\n    1. For a deletion with a new Master-Detail field, soft delete (send to the Recycle Bin) all detail records before proceeding to delete the Master-Detail field, or the deletion fails. During the deletion, detail records are permanently deleted from the Recycle Bin and cannot be recovered.\n\n    2. For a deletion that converts a Lookup field relationship to a Master-Detail relationship, detail records must reference a master record or be soft-deleted (sent to the Recycle Bin) for the deletion to succeed. However, a successful deletion permanently deletes any detail records in the Recycle Bin.",
          "name": "check-only",
          "summary": "Validate delete command but don't delete anything from the org or the local project.",
          "allowNo": false,
          "type": "boolean"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you.",
          "name": "wait",
          "summary": "Number of minutes to wait for the command to finish.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "tests": {
          "description": "If a test name contains a space, enclose it in double quotes.\nFor multiple test names, use one of the following formats:\n\n- Repeat the flag for multiple test names: --tests Test1 --tests Test2 --tests \"Test With Space\"\n- Separate the test names with spaces: --tests Test1 Test2 \"Test With Space\"",
          "helpGroup": "Test",
          "name": "tests",
          "summary": "Apex tests to run when --test-level is RunSpecifiedTests.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "test-level": {
          "aliases": [
            "testlevel"
          ],
          "char": "l",
          "deprecateAliases": true,
          "description": "Valid values are:\n\n- NoTestRun — No tests are run. This test level applies only to deployments to development environments, such as sandbox, Developer Edition, or trial orgs. This test level is the default for development environments.\n\n- RunSpecifiedTests — Runs only the tests that you specify with the --tests flag. Code coverage requirements differ from the default coverage requirements when using this test level. Executed tests must comprise a minimum of 75% code coverage for each class and trigger in the deployment package. This coverage is computed for each class and trigger individually and is different than the overall coverage percentage.\n\n- RunLocalTests — All tests in your org are run, except the ones that originate from installed managed and unlocked packages. This test level is the default for production deployments that include Apex classes or triggers.\n\n- RunAllTestsInOrg — All tests in your org are run, including tests of managed packages.\n\nIf you don’t specify a test level, the default behavior depends on the contents of your deployment package and target org. For more information, see “Running Tests in a Deployment” in the Metadata API Developer Guide.",
          "helpGroup": "Test",
          "name": "test-level",
          "summary": "Deployment Apex testing level.",
          "hasDynamicHelp": false,
          "multiple": false,
          "options": [
            "NoTestRun",
            "RunSpecifiedTests",
            "RunLocalTests",
            "RunAllTestsInOrg"
          ],
          "type": "option"
        },
        "no-prompt": {
          "aliases": [
            "noprompt"
          ],
          "char": "r",
          "deprecateAliases": true,
          "name": "no-prompt",
          "summary": "Don't prompt for delete confirmation.",
          "allowNo": false,
          "type": "boolean"
        },
        "metadata": {
          "char": "m",
          "description": "If you specify this parameter, don’t specify --source-dir.",
          "name": "metadata",
          "summary": "Metadata components to delete.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "source-dir": {
          "aliases": [
            "sourcepath"
          ],
          "char": "p",
          "deprecateAliases": true,
          "description": "The supplied paths can be a single file (in which case the operation is applied to only one file) or a folder (in which case the operation is applied to all metadata types in the directory and its sub-directories).\n\nIf you specify this parameter, don’t specify --metadata.",
          "name": "source-dir",
          "summary": "Source file paths to delete.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "track-source": {
          "aliases": [
            "tracksource"
          ],
          "char": "t",
          "deprecateAliases": true,
          "exclusive": [
            "check-only"
          ],
          "name": "track-source",
          "summary": "If the delete succeeds, update the source tracking information.",
          "allowNo": false,
          "type": "boolean"
        },
        "force-overwrite": {
          "aliases": [
            "forceoverwrite"
          ],
          "char": "f",
          "dependsOn": [
            "track-source"
          ],
          "deprecateAliases": true,
          "name": "force-overwrite",
          "summary": "Ignore conflict warnings and overwrite changes to the org.",
          "allowNo": false,
          "type": "boolean"
        },
        "verbose": {
          "name": "verbose",
          "summary": "Verbose output of the delete result.",
          "allowNo": false,
          "type": "boolean"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:delete:source",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Delete source from your project and from a non-source-tracked org.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "delete",
        "source.js"
      ],
      "aliasPermutations": [
        "force:source:delete",
        "source:force:delete",
        "source:delete:force",
        "force:delete:source",
        "delete:force:source",
        "delete:source:force"
      ],
      "permutations": [
        "project:delete:source",
        "delete:project:source",
        "delete:source:project",
        "project:source:delete",
        "source:project:delete",
        "source:delete:project"
      ]
    },
    "project:delete:tracking": {
      "aliases": [
        "force:source:tracking:clear"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "WARNING: This command deletes or overwrites all existing source tracking files. Use with extreme caution.\n\nDeletes all local source tracking information. When you next run 'project deploy preview', Salesforce CLI displays all local and remote files as changed, and any files with the same name are listed as conflicts.",
      "examples": [
        "Delete local source tracking for the org with alias \"my-scratch\":\n$ <%= config.bin %> <%= command.id %> --target-org my-scratch"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "aliases": [
            "apiversion"
          ],
          "deprecateAliases": true,
          "description": "Override the api version used for api requests made by this command",
          "name": "api-version",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "loglevel": {
          "deprecated": {
            "message": "The loglevel flag is no longer in use on this command. You may use it without error, but it will be ignored.\nSet the log level using the `SFDX_LOG_LEVEL` environment variable."
          },
          "hidden": true,
          "name": "loglevel",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "aliases": [
            "targetusername",
            "u"
          ],
          "char": "o",
          "deprecateAliases": true,
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "no-prompt": {
          "aliases": [
            "noprompt"
          ],
          "char": "p",
          "deprecateAliases": true,
          "name": "no-prompt",
          "summary": "Don't prompt for source tracking override confirmation.",
          "allowNo": false,
          "type": "boolean"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:delete:tracking",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Delete all local source tracking information.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "delete",
        "tracking.js"
      ],
      "aliasPermutations": [
        "force:source:tracking:clear",
        "source:force:tracking:clear",
        "source:tracking:force:clear",
        "source:tracking:clear:force",
        "force:tracking:source:clear",
        "tracking:force:source:clear",
        "tracking:source:force:clear",
        "tracking:source:clear:force",
        "force:tracking:clear:source",
        "tracking:force:clear:source",
        "tracking:clear:force:source",
        "tracking:clear:source:force",
        "force:source:clear:tracking",
        "source:force:clear:tracking",
        "source:clear:force:tracking",
        "source:clear:tracking:force",
        "force:clear:source:tracking",
        "clear:force:source:tracking",
        "clear:source:force:tracking",
        "clear:source:tracking:force",
        "force:clear:tracking:source",
        "clear:force:tracking:source",
        "clear:tracking:force:source",
        "clear:tracking:source:force"
      ],
      "permutations": [
        "project:delete:tracking",
        "delete:project:tracking",
        "delete:tracking:project",
        "project:tracking:delete",
        "tracking:project:delete",
        "tracking:delete:project"
      ]
    },
    "project:deploy:cancel": {
      "aliases": [
        "deploy:metadata:cancel"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Use this command to cancel a deploy operation that hasn't yet completed in the org. Deploy operations include standard deploys, quick deploys, deploy validations, and deploy cancellations.\n\nRun this command by either passing it a job ID or specifying the --use-most-recent flag to use the job ID of the most recent deploy operation.",
      "examples": [
        "Cancel a deploy operation using a job ID:\n<%= config.bin %> <%= command.id %> --job-id 0Af0x000017yLUFCA2",
        "Cancel the most recent deploy operation:\n<%= config.bin %> <%= command.id %> --use-most-recent"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "summary": "Username or alias of the target org.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "async": {
          "description": "The command immediately returns the control of the terminal to you. This way, you can continue to use the CLI. To resume watching the cancellation, run \"<%= config.bin %> project deploy resume\". To check the status of the cancellation, run \"<%= config.bin %> project deploy report\".",
          "exclusive": [
            "wait"
          ],
          "name": "async",
          "summary": "Run the command asynchronously.",
          "allowNo": false,
          "type": "boolean"
        },
        "job-id": {
          "char": "i",
          "description": "These commands return a job ID if they time out or you specified the --async flag:\n\n- <%= config.bin %> project deploy start\n- <%= config.bin %> project deploy validate\n- <%= config.bin %> project deploy quick\n- <%= config.bin %> project deploy cancel\n\nThe job ID is valid for 10 days from when you started the deploy operation.",
          "name": "job-id",
          "summary": "Job ID of the deploy operation you want to cancel.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "use-most-recent": {
          "char": "r",
          "description": "For performance reasons, this flag uses job IDs for deploy operations that started only in the past 3 days or less. If your most recent deploy operations was more than 3 days ago, this flag won't find a job ID.",
          "name": "use-most-recent",
          "summary": "Use the job ID of the most recent deploy operation.",
          "allowNo": false,
          "type": "boolean"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you. To resume watching the cancellation, run \"<%= config.bin %> project deploy resume\". To check the status of the cancellation, run \"<%= config.bin %> project deploy report\".",
          "exclusive": [
            "async"
          ],
          "name": "wait",
          "summary": "Number of minutes to wait for the command to complete and display results.",
          "hasDynamicHelp": true,
          "helpValue": "<minutes>",
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:cancel",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Cancel a deploy operation.",
      "enableJsonFlag": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "cancel.js"
      ],
      "aliasPermutations": [
        "deploy:metadata:cancel",
        "metadata:deploy:cancel",
        "metadata:cancel:deploy",
        "deploy:cancel:metadata",
        "cancel:deploy:metadata",
        "cancel:metadata:deploy"
      ],
      "permutations": [
        "project:deploy:cancel",
        "deploy:project:cancel",
        "deploy:cancel:project",
        "project:cancel:deploy",
        "cancel:project:deploy",
        "cancel:deploy:project"
      ]
    },
    "project:deploy:preview": {
      "aliases": [
        "deploy:metadata:preview"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "You must run this command from within a project.\n\nThe command outputs a table that describes what will happen if you run the \"<%= config.bin %> project deploy start\" command. The table lists the metadata components that will be deployed and deleted. The table also lists the current conflicts between files in your local project and components in the org. Finally, the table lists the files that won't be deployed because they're included in your .forceignore file.\n\nIf your org allows source tracking, then this command displays potential conflicts between the org and your local project. Some orgs, such as production org, never allow source tracking. Source tracking is enabled by default on scratch and sandbox orgs; you can disable source tracking when you create the orgs by specifying the --no-track-source flag on the \"<%= config.bin %> org create scratch|sandbox\" commands.\n\nTo preview the deployment of multiple metadata components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.",
      "examples": [
        "NOTE: The commands to preview a deployment and actually deploy it use similar flags. We provide a few preview examples here, but see the help for \"<%= config.bin %> project deploy start\" for more examples that you can adapt for previewing.",
        "Preview the deployment of source files in a directory, such as force-app, to your default org:\n<%= config.bin %> <%= command.id %>  --source-dir force-app",
        "Preview the deployment of all Apex classes to an org with alias \"my-scratch\":\n<%= config.bin %> <%= command.id %> --metadata ApexClass --target-org my-scratch",
        "Preview deployment of a specific Apex class:\n<%= config.bin %> <%= command.id %> --metadata ApexClass:MyApexClass",
        "Preview deployment of all components listed in a manifest:\n<%= config.bin %> <%= command.id %> --manifest path/to/package.xml"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "ignore-conflicts": {
          "char": "c",
          "description": "This flag applies only to orgs that allow source tracking. It has no effect on orgs that don't allow it, such as production orgs.",
          "name": "ignore-conflicts",
          "summary": "Don't display conflicts in preview of the deployment.",
          "allowNo": false,
          "type": "boolean"
        },
        "manifest": {
          "char": "x",
          "description": "All child components are included. If you specify this flag, don’t specify --metadata or --source-dir.",
          "exclusive": [
            "source-dir",
            "metadata"
          ],
          "name": "manifest",
          "summary": "Full file path for manifest (package.xml) of components to preview.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "exclusive": [
            "manifest",
            "source-dir"
          ],
          "name": "metadata",
          "summary": "Metadata component names to preview.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "source-dir": {
          "char": "d",
          "description": "The supplied path can be to a single file (in which case the operation is applied to only one file) or to a folder (in which case the operation is applied to all metadata types in the directory and its subdirectories).\n\nIf you specify this flag, don’t specify --metadata or --manifest.",
          "exclusive": [
            "manifest",
            "metadata"
          ],
          "name": "source-dir",
          "summary": "Path to the local source files to preview.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "concise": {
          "name": "concise",
          "summary": "Show only the changes that will be deployed; omits files that are forceignored.",
          "allowNo": false,
          "type": "boolean"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:preview",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Preview a deployment to see what will deploy to the org, the potential conflicts, and the ignored files.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "preview.js"
      ],
      "aliasPermutations": [
        "deploy:metadata:preview",
        "metadata:deploy:preview",
        "metadata:preview:deploy",
        "deploy:preview:metadata",
        "preview:deploy:metadata",
        "preview:metadata:deploy"
      ],
      "permutations": [
        "project:deploy:preview",
        "deploy:project:preview",
        "deploy:preview:project",
        "project:preview:deploy",
        "preview:project:deploy",
        "preview:deploy:project"
      ]
    },
    "project:deploy:quick": {
      "aliases": [
        "deploy:metadata:quick"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Before you run this command, first create a validated deployment with the \"<%= config.bin %> project deploy validate\" command, which returns a job ID. Validated deployments haven't been deployed to the org yet; you deploy them with this command. Either pass the job ID to this command or use the --use-most-recent flag to use the job ID of the most recently validated deployment. For the quick deploy to succeed, the associated validated deployment must also have succeeded.\n\nExecuting this quick deploy command takes less time than a standard deploy because it skips running Apex tests. These tests were previously run as part of the validation. Validating first and then running a quick deploy is useful if the deployment to your production org take several hours and you don’t want to risk a failed deploy.\n\nThis command doesn't support source-tracking. The source you deploy overwrites the corresponding metadata in your org. This command doesn’t attempt to merge your source with the versions in your org.\n\nNote: Don't use this command on sandboxes; the command is intended to be used on production orgs. By default, sandboxes don't run tests during a deploy. Use \"<%= config.bin %> project deploy start\" instead.",
      "examples": [
        "Run a quick deploy to your default org using a job ID:\n<%= config.bin %> <%= command.id %> --job-id 0Af0x000017yLUFCA2",
        "Asynchronously run a quick deploy of the most recently validated deployment to an org with alias \"my-prod-org\":\n<%= config.bin %> <%= command.id %> --async --use-most-recent --target-org my-prod-org"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "async": {
          "description": "The command immediately returns the control of the terminal to you. This way, you can continue to use the CLI. To resume watching the deploy, run \"<%= config.bin %> project deploy resume\". To check the status of the deploy, run \"<%= config.bin %> project deploy report\".",
          "exclusive": [
            "wait"
          ],
          "name": "async",
          "summary": "Run the command asynchronously.",
          "allowNo": false,
          "type": "boolean"
        },
        "concise": {
          "exclusive": [
            "verbose"
          ],
          "name": "concise",
          "summary": "Show concise output of the deploy result.",
          "allowNo": false,
          "type": "boolean"
        },
        "job-id": {
          "char": "i",
          "description": "The job ID is valid for 10 days from when you started the validation.",
          "name": "job-id",
          "summary": "Job ID of the deployment you want to quick deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "summary": "Username or alias of the target org.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "use-most-recent": {
          "char": "r",
          "description": "For performance reasons, this flag uses only job IDs that were validated in the past 3 days or less. If your most recent deployment validation was more than 3 days ago, this flag won't find a job ID.",
          "name": "use-most-recent",
          "summary": "Use the job ID of the most recently validated deployment.",
          "allowNo": false,
          "type": "boolean"
        },
        "verbose": {
          "exclusive": [
            "concise"
          ],
          "name": "verbose",
          "summary": "Show verbose output of the deploy result.",
          "allowNo": false,
          "type": "boolean"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you. To resume watching the deploy, run \"<%= config.bin %> project deploy resume\". To check the status of the deploy, run \"<%= config.bin %> project deploy report\".",
          "exclusive": [
            "async"
          ],
          "name": "wait",
          "summary": "Number of minutes to wait for the command to complete and display results.",
          "default": "33 minutes",
          "hasDynamicHelp": true,
          "helpValue": "<minutes>",
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "char": "a",
          "description": "Use this flag to override the default API version with the API version of your package.xml file. The default API version is the latest version supported by the CLI.",
          "name": "api-version",
          "summary": "Target API version for the deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:quick",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Quickly deploy a validated deployment to an org.",
      "enableJsonFlag": true,
      "errorCodes": {
        "header": "ERROR CODES",
        "body": [
          {
            "name": "Succeeded (0)",
            "description": "The deploy succeeded."
          },
          {
            "name": "Canceled (1)",
            "description": "The deploy was canceled."
          },
          {
            "name": "Failed (1)",
            "description": "The deploy failed."
          },
          {
            "name": "SucceededPartial (68)",
            "description": "The deploy partially succeeded."
          },
          {
            "name": "InProgress (69)",
            "description": "The deploy is in progress."
          },
          {
            "name": "Pending (69)",
            "description": "The deploy is pending."
          },
          {
            "name": "Canceling (69)",
            "description": "The deploy is being canceled."
          }
        ]
      },
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "quick.js"
      ],
      "aliasPermutations": [
        "deploy:metadata:quick",
        "metadata:deploy:quick",
        "metadata:quick:deploy",
        "deploy:quick:metadata",
        "quick:deploy:metadata",
        "quick:metadata:deploy"
      ],
      "permutations": [
        "project:deploy:quick",
        "deploy:project:quick",
        "deploy:quick:project",
        "project:quick:deploy",
        "quick:project:deploy",
        "quick:deploy:project"
      ]
    },
    "project:deploy:report": {
      "aliases": [
        "deploy:metadata:report"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Deploy operations include standard deploys, quick deploys, deploy validations, and deploy cancellations.\n\nRun this command by either passing it a job ID or specifying the --use-most-recent flag to use the job ID of the most recent deploy operation. If you specify the --wait flag, the command polls for the status every second until the timeout of --wait minutes. If you don't specify the --wait flag, the command simply checks and displays the status of the deploy; the command doesn't poll for the status.\n\nYou typically don't specify the --target-org flag because the cached job already references the org to which you deployed. But if you run this command on a computer different than the one from which you deployed, then you must specify the --target-org and it must point to the same org.\n\nThis command doesn't update source tracking information.",
      "examples": [
        "Check the status using a job ID:\n<%= config.bin %> <%= command.id %> --job-id 0Af0x000017yLUFCA2",
        "Check the status of the most recent deploy operation:\n<%= config.bin %> <%= command.id %> --use-most-recent",
        "Poll for the status using a job ID and target org:\n<%= config.bin %> <%= command.id %> --job-id 0Af0x000017yLUFCA2 --target-org me@my.org --wait 30"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "summary": "Username or alias of the target org.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "job-id": {
          "char": "i",
          "description": "These commands return a job ID if they time out or you specified the --async flag:\n\n- <%= config.bin %> project deploy start\n- <%= config.bin %> project deploy validate\n- <%= config.bin %> project deploy quick\n- <%= config.bin %> project deploy cancel\n\nThe job ID is valid for 10 days from when you started the deploy operation.",
          "name": "job-id",
          "summary": "Job ID of the deploy operation you want to check the status of.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "use-most-recent": {
          "char": "r",
          "description": "For performance reasons, this flag uses job IDs for deploy operations that started only in the past 3 days or less. If your most recent operation was more than 3 days ago, this flag won't find a job ID.",
          "name": "use-most-recent",
          "summary": "Use the job ID of the most recent deploy operation.",
          "allowNo": false,
          "type": "boolean"
        },
        "coverage-formatters": {
          "description": "For multiple formatters, repeat the flag for each formatter.\n--coverage-formatters lcov --coverage-formatters clover",
          "helpGroup": "Test",
          "name": "coverage-formatters",
          "summary": "Format of the code coverage results.",
          "hasDynamicHelp": false,
          "multiple": true,
          "options": [
            "clover",
            "cobertura",
            "html-spa",
            "html",
            "json",
            "json-summary",
            "lcovonly",
            "none",
            "teamcity",
            "text",
            "text-summary"
          ],
          "type": "option"
        },
        "junit": {
          "helpGroup": "Test",
          "name": "junit",
          "summary": "Output JUnit test results.",
          "allowNo": false,
          "type": "boolean"
        },
        "results-dir": {
          "helpGroup": "Test",
          "name": "results-dir",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "coverage-formatters",
                "junit"
              ]
            }
          ],
          "summary": "Output directory for code coverage and JUnit results; defaults to the deploy ID.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you and returns the job ID. To resume the deployment, run \"<%= config.bin %> project deploy resume\". To check the status of the deployment, run \"<%= config.bin %> project deploy report\".",
          "name": "wait",
          "summary": "Number of minutes to wait for command to complete and display results.",
          "hasDynamicHelp": true,
          "helpValue": "<minutes>",
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:report",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Check or poll for the status of a deploy operation.",
      "enableJsonFlag": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "report.js"
      ],
      "aliasPermutations": [
        "deploy:metadata:report",
        "metadata:deploy:report",
        "metadata:report:deploy",
        "deploy:report:metadata",
        "report:deploy:metadata",
        "report:metadata:deploy"
      ],
      "permutations": [
        "project:deploy:report",
        "deploy:project:report",
        "deploy:report:project",
        "project:report:deploy",
        "report:project:deploy",
        "report:deploy:project"
      ]
    },
    "project:deploy:resume": {
      "aliases": [
        "deploy:metadata:resume"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Use this command to resume watching a deploy operation if the original command times out or you specified the --async flag. Deploy operations include standard deploys, quick deploys, deploy validations, and deploy cancellations. This command doesn't resume the original operation itself, because the operation always continues after you've started it, regardless of whether you're watching it or not. When the deploy completes, source tracking information is updated as needed.\n\nRun this command by either passing it a job ID or specifying the --use-most-recent flag to use the job ID of the most recent deploy operation.",
      "examples": [
        "Resume watching a deploy operation using a job ID:\n<%= config.bin %> <%= command.id %> --job-id 0Af0x000017yLUFCA2",
        "Resume watching the most recent deploy operation:\n<%= config.bin %> <%= command.id %> --use-most-recent"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "concise": {
          "exclusive": [
            "verbose"
          ],
          "name": "concise",
          "summary": "Show concise output of the deploy operation result.",
          "allowNo": false,
          "type": "boolean"
        },
        "job-id": {
          "char": "i",
          "description": "These commands return a job ID if they time out or you specified the --async flag:\n\n- <%= config.bin %> project deploy start\n- <%= config.bin %> project deploy validate\n- <%= config.bin %> project deploy quick\n- <%= config.bin %> project deploy cancel\n\nThe job ID is valid for 10 days from when you started the deploy operation.",
          "name": "job-id",
          "summary": "Job ID of the deploy operation you want to resume.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "use-most-recent": {
          "char": "r",
          "description": "For performance reasons, this flag uses job IDs for deploy operations that started only in the past 3 days or less. If your most recent operation was more than 3 days ago, this flag won't find a job ID.",
          "name": "use-most-recent",
          "summary": "Use the job ID of the most recent deploy operation.",
          "allowNo": false,
          "type": "boolean"
        },
        "verbose": {
          "exclusive": [
            "concise"
          ],
          "name": "verbose",
          "summary": "Show verbose output of the deploy operation result.",
          "allowNo": false,
          "type": "boolean"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you. To resume watching the deploy operation, run this command again. To check the status of the deploy operation, run \"<%= config.bin %> project deploy report\".",
          "name": "wait",
          "summary": "Number of minutes to wait for the command to complete and display results.",
          "hasDynamicHelp": true,
          "helpValue": "<minutes>",
          "multiple": false,
          "type": "option"
        },
        "coverage-formatters": {
          "description": "For multiple formatters, repeat the flag for each formatter.\n--coverage-formatters lcov --coverage-formatters clover",
          "helpGroup": "Test",
          "name": "coverage-formatters",
          "summary": "Format of the code coverage results.",
          "hasDynamicHelp": false,
          "multiple": true,
          "options": [
            "clover",
            "cobertura",
            "html-spa",
            "html",
            "json",
            "json-summary",
            "lcovonly",
            "none",
            "teamcity",
            "text",
            "text-summary"
          ],
          "type": "option"
        },
        "junit": {
          "helpGroup": "Test",
          "name": "junit",
          "summary": "Output JUnit test results.",
          "allowNo": false,
          "type": "boolean"
        },
        "results-dir": {
          "helpGroup": "Test",
          "name": "results-dir",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "coverage-formatters",
                "junit"
              ]
            }
          ],
          "summary": "Output directory for code coverage and JUnit results; defaults to the deploy ID.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:resume",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Resume watching a deploy operation and update source tracking when the deploy completes.",
      "enableJsonFlag": true,
      "envVariablesSection": {
        "header": "ENVIRONMENT VARIABLES",
        "body": [
          {
            "name": "SF_USE_PROGRESS_BAR",
            "description": "Set to false to disable the progress bar when running the metadata deploy command."
          }
        ]
      },
      "errorCodes": {
        "header": "ERROR CODES",
        "body": [
          {
            "name": "Succeeded (0)",
            "description": "The deploy succeeded."
          },
          {
            "name": "Canceled (1)",
            "description": "The deploy was canceled."
          },
          {
            "name": "Failed (1)",
            "description": "The deploy failed."
          },
          {
            "name": "SucceededPartial (68)",
            "description": "The deploy partially succeeded."
          },
          {
            "name": "InProgress (69)",
            "description": "The deploy is in progress."
          },
          {
            "name": "Pending (69)",
            "description": "The deploy is pending."
          },
          {
            "name": "Canceling (69)",
            "description": "The deploy is being canceled."
          }
        ]
      },
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "resume.js"
      ],
      "aliasPermutations": [
        "deploy:metadata:resume",
        "metadata:deploy:resume",
        "metadata:resume:deploy",
        "deploy:resume:metadata",
        "resume:deploy:metadata",
        "resume:metadata:deploy"
      ],
      "permutations": [
        "project:deploy:resume",
        "deploy:project:resume",
        "deploy:resume:project",
        "project:resume:deploy",
        "resume:project:deploy",
        "resume:deploy:project"
      ]
    },
    "project:deploy:start": {
      "aliases": [
        "deploy:metadata"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "You must run this command from within a project.\n\nMetadata components are deployed in source format by default. Deploy them in metadata format by specifying the --metadata-dir flag, which specifies the root directory or ZIP file that contains the metadata formatted files you want to deploy.\n\nIf your org allows source tracking, then this command tracks the changes in your source. Some orgs, such as production orgs, never allow source tracking. Source tracking is enabled by default on scratch and sandbox orgs; you can disable source tracking when you create the orgs by specifying the --no-track-source flag on the \"<%= config.bin %> org create scratch|sandbox\" commands.\n\nTo deploy multiple metadata components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.",
      "examples": [
        "Deploy local changes not in the org; uses your default org:\n<%= config.bin %> <%= command.id %>",
        "Deploy all source files in the \"force-app\" directory to an org with alias \"my-scratch\"; show only concise output, in other words don't print a list of all the source that was deployed:\n<%= config.bin %> <%= command.id %>  --source-dir force-app --target-org my-scratch --concise",
        "Deploy all the Apex classes and custom objects that are in the \"force-app\" directory. The list views, layouts, etc, that are associated with the custom objects are also deployed. Both examples are equivalent:\n<%= config.bin %> <%= command.id %> --source-dir force-app/main/default/classes force-app/main/default/objects\n<%= config.bin %> <%= command.id %> --source-dir force-app/main/default/classes --source-dir force-app/main/default/objects",
        "Deploy all Apex classes that are in all package directories defined in the \"sfdx-project.json\" file:\n<%= config.bin %> <%= command.id %> --metadata ApexClass",
        "Deploy a specific Apex class; ignore any conflicts between the local project and org (be careful with this flag, because it will overwrite the Apex class in the org if there are conflicts!):\n<%= config.bin %> <%= command.id %> --metadata ApexClass:MyApexClass --ignore-conflicts",
        "Deploy specific Apex classes that match a pattern; in this example, deploy Apex classes whose names contain the string \"MyApex\". Also ignore any deployment warnings (again, be careful with this flag! You typically want to see the warnings):\n<%= config.bin %> <%= command.id %> --metadata 'ApexClass:MyApex*' --ignore-warnings",
        "Deploy a custom object called ExcitingObject that's in the SBQQ namespace:\nsf <%= command.id %> --metadata CustomObject:SBQQ__ExcitingObject",
        "Deploy all custom objects in the SBQQ namespace by using a wildcard and quotes:\nsf <%= command.id %> --metadata 'CustomObject:SBQQ__*'",
        "Deploy all custom objects and Apex classes found in all defined package directories (both examples are equivalent):\n<%= config.bin %> <%= command.id %> --metadata CustomObject ApexClass\n<%= config.bin %> <%= command.id %> --metadata CustomObject --metadata ApexClass",
        "Deploy all Apex classes and a profile that has a space in its name:\n<%= config.bin %> <%= command.id %> --metadata ApexClass --metadata \"Profile:My Profile\"",
        "Deploy all components listed in a manifest:\n<%= config.bin %> <%= command.id %> --manifest path/to/package.xml",
        "Run the tests that aren’t in any managed packages as part of a deployment:\n<%= config.bin %> <%= command.id %> --metadata ApexClass --test-level RunLocalTests",
        "Deploy all metadata formatted files in the \"MDAPI\" directory:\n<%= config.bin %> <%= command.id %> --metadata-dir MDAPI",
        "Deploy all metadata formatted files in the \"MDAPI\" directory; items listed in the MDAPI/destructiveChangesPre.xml and MDAPI/destructiveChangesPost.xml manifests are immediately eligible for deletion rather than stored in the Recycle Bin:\n<%= config.bin %> <%= command.id %> --metadata-dir MDAPI --purge-on-delete"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "char": "a",
          "description": "Use this flag to override the default API version with the API version of your package.xml file. The default API version is the latest version supported by the CLI.",
          "name": "api-version",
          "summary": "Target API version for the deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "async": {
          "description": "The command immediately returns the job ID and control of the terminal to you. This way, you can continue to use the CLI. To resume the deployment, run \"<%= config.bin %> project deploy resume\". To check the status of the deployment, run \"<%= config.bin %> project deploy report\".",
          "exclusive": [
            "wait"
          ],
          "name": "async",
          "summary": "Run the command asynchronously.",
          "allowNo": false,
          "type": "boolean"
        },
        "concise": {
          "exclusive": [
            "verbose"
          ],
          "name": "concise",
          "summary": "Show concise output of the deploy result.",
          "allowNo": false,
          "type": "boolean"
        },
        "dry-run": {
          "name": "dry-run",
          "summary": "Validate deploy and run Apex tests but don’t save to the org.",
          "allowNo": false,
          "type": "boolean"
        },
        "ignore-conflicts": {
          "char": "c",
          "description": "This flag applies only to orgs that allow source tracking. It has no effect on orgs that don't allow it, such as production orgs.",
          "name": "ignore-conflicts",
          "summary": "Ignore conflicts and deploy local files, even if they overwrite changes in the org.",
          "allowNo": false,
          "type": "boolean"
        },
        "ignore-errors": {
          "char": "r",
          "description": "Never use this flag when deploying to a production org. If you specify it, components without errors are deployed and components with errors are skipped, and could result in an inconsistent production org.",
          "name": "ignore-errors",
          "summary": "Ignore any errors and don’t roll back deployment.",
          "allowNo": false,
          "type": "boolean"
        },
        "ignore-warnings": {
          "char": "g",
          "description": "If you specify this flag, and a warning occurs, the success status of the deployment is set to true. If you don't specify this flag, and a warning occurs, then the success status is set to false, and the warning is treated like an error.\n\nThis flag is useful in a CI environment and your deployment includes destructive changes; if you try to delete a component that doesn't exist in the org, you get a warning. In this case, to ensure that the command returns a success value of true, specify this flag.",
          "name": "ignore-warnings",
          "summary": "Ignore warnings and allow a deployment to complete successfully.",
          "allowNo": false,
          "type": "boolean"
        },
        "manifest": {
          "char": "x",
          "description": "All child components are included. If you specify this flag, don’t specify --metadata or --source-dir.",
          "exclusive": [
            "source-dir",
            "metadata",
            "metadata-dir"
          ],
          "helpGroup": "Source Format",
          "name": "manifest",
          "summary": "Full file path for manifest (package.xml) of components to deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "exclusive": [
            "manifest",
            "source-dir",
            "metadata-dir"
          ],
          "helpGroup": "Source Format",
          "name": "metadata",
          "summary": "Metadata component names to deploy. Wildcards (`*` ) supported as long as you use quotes, such as `ApexClass:MyClass*`.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "metadata-dir": {
          "exclusive": [
            "manifest",
            "source-dir",
            "metadata"
          ],
          "helpGroup": "Metadata API Format",
          "name": "metadata-dir",
          "summary": "Root of directory or zip file of metadata formatted files to deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "single-package": {
          "dependsOn": [
            "metadata-dir"
          ],
          "helpGroup": "Metadata API Format",
          "name": "single-package",
          "summary": "Indicates that the metadata zip file points to a directory structure for a single package.",
          "allowNo": false,
          "type": "boolean"
        },
        "source-dir": {
          "char": "d",
          "description": "The supplied path can be to a single file (in which case the operation is applied to only one file) or to a folder (in which case the operation is applied to all metadata types in the directory and its subdirectories).\n\nIf you specify this flag, don’t specify --metadata or --manifest.",
          "exclusive": [
            "manifest",
            "metadata",
            "metadata-dir"
          ],
          "helpGroup": "Source Format",
          "name": "source-dir",
          "summary": "Path to the local source files to deploy.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "tests": {
          "char": "t",
          "description": "If a test name contains a space, enclose it in double quotes.\nFor multiple test names, use one of the following formats:\n\n- Repeat the flag for multiple test names: --tests Test1 --tests Test2 --tests \"Test With Space\"\n- Separate the test names with spaces: --tests Test1 Test2 \"Test With Space\"",
          "helpGroup": "Test",
          "name": "tests",
          "summary": "Apex tests to run when --test-level is RunSpecifiedTests.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "test-level": {
          "char": "l",
          "description": "Valid values are:\n\n- NoTestRun — No tests are run. This test level applies only to deployments to development environments, such as sandbox, Developer Edition, or trial orgs. This test level is the default for development environments.\n\n- RunSpecifiedTests — Runs only the tests that you specify with the --tests flag. Code coverage requirements differ from the default coverage requirements when using this test level. Executed tests must comprise a minimum of 75% code coverage for each class and trigger in the deployment package. This coverage is computed for each class and trigger individually and is different than the overall coverage percentage.\n\n- RunLocalTests — All tests in your org are run, except the ones that originate from installed managed and unlocked packages. This test level is the default for production deployments that include Apex classes or triggers.\n\n- RunAllTestsInOrg — All tests in your org are run, including tests of managed packages.\n\n  If you don’t specify a test level, the default behavior depends on the contents of your deployment package and target org. For more information, see [Running Tests in a Deployment](https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deploy_running_tests.htm) in the \"Metadata API Developer Guide\".",
          "helpGroup": "Test",
          "name": "test-level",
          "summary": "Deployment Apex testing level.",
          "hasDynamicHelp": false,
          "multiple": false,
          "options": [
            "NoTestRun",
            "RunSpecifiedTests",
            "RunLocalTests",
            "RunAllTestsInOrg"
          ],
          "type": "option"
        },
        "verbose": {
          "exclusive": [
            "concise"
          ],
          "name": "verbose",
          "summary": "Show verbose output of the deploy result.",
          "allowNo": false,
          "type": "boolean"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you and returns the job ID. To resume the deployment, run \"<%= config.bin %> project deploy resume\". To check the status of the deployment, run \"<%= config.bin %> project deploy report\".",
          "exclusive": [
            "async"
          ],
          "name": "wait",
          "summary": "Number of minutes to wait for command to complete and display results.",
          "hasDynamicHelp": true,
          "helpValue": "<minutes>",
          "multiple": false,
          "type": "option"
        },
        "purge-on-delete": {
          "helpGroup": "Delete",
          "name": "purge-on-delete",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "pre-destructive-changes",
                "manifest",
                "metadata-dir",
                "post-destructive-changes"
              ]
            }
          ],
          "summary": "Specify that deleted components in the destructive changes manifest file are immediately eligible for deletion rather than being stored in the Recycle Bin.",
          "allowNo": false,
          "type": "boolean"
        },
        "pre-destructive-changes": {
          "dependsOn": [
            "manifest"
          ],
          "helpGroup": "Delete",
          "name": "pre-destructive-changes",
          "summary": "File path for a manifest (destructiveChangesPre.xml) of components to delete before the deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "post-destructive-changes": {
          "dependsOn": [
            "manifest"
          ],
          "helpGroup": "Delete",
          "name": "post-destructive-changes",
          "summary": "File path for a manifest (destructiveChangesPost.xml) of components to delete after the deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "coverage-formatters": {
          "description": "For multiple formatters, repeat the flag for each formatter.\n--coverage-formatters lcov --coverage-formatters clover",
          "helpGroup": "Test",
          "name": "coverage-formatters",
          "summary": "Format of the code coverage results.",
          "hasDynamicHelp": false,
          "multiple": true,
          "options": [
            "clover",
            "cobertura",
            "html-spa",
            "html",
            "json",
            "json-summary",
            "lcovonly",
            "none",
            "teamcity",
            "text",
            "text-summary"
          ],
          "type": "option"
        },
        "junit": {
          "helpGroup": "Test",
          "name": "junit",
          "summary": "Output JUnit test results.",
          "allowNo": false,
          "type": "boolean"
        },
        "results-dir": {
          "helpGroup": "Test",
          "name": "results-dir",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "coverage-formatters",
                "junit"
              ]
            }
          ],
          "summary": "Output directory for code coverage and JUnit results; defaults to the deploy ID.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:start",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Deploy metadata to an org from your local project.",
      "enableJsonFlag": true,
      "configurationVariablesSection": {
        "header": "CONFIGURATION VARIABLES",
        "body": [
          {
            "name": "target-org",
            "description": "Username or alias of the org that all commands run against by default. (sf only)"
          },
          {
            "name": "org-api-version",
            "description": "API version of your project. Default: API version of your Dev Hub org."
          }
        ]
      },
      "envVariablesSection": {
        "header": "ENVIRONMENT VARIABLES",
        "body": [
          {
            "name": "SF_TARGET_ORG",
            "description": "Username or alias of your default org. Overrides the target-org configuration variable."
          },
          {
            "name": "SF_USE_PROGRESS_BAR",
            "description": "Set to false to disable the progress bar when running the metadata deploy command."
          }
        ]
      },
      "errorCodes": {
        "header": "ERROR CODES",
        "body": [
          {
            "name": "Succeeded (0)",
            "description": "The deploy succeeded."
          },
          {
            "name": "Canceled (1)",
            "description": "The deploy was canceled."
          },
          {
            "name": "Failed (1)",
            "description": "The deploy failed."
          },
          {
            "name": "SucceededPartial (68)",
            "description": "The deploy partially succeeded."
          },
          {
            "name": "InProgress (69)",
            "description": "The deploy is in progress."
          },
          {
            "name": "Pending (69)",
            "description": "The deploy is pending."
          },
          {
            "name": "Canceling (69)",
            "description": "The deploy is being canceled."
          }
        ]
      },
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "start.js"
      ],
      "aliasPermutations": [
        "deploy:metadata",
        "metadata:deploy"
      ],
      "permutations": [
        "project:deploy:start",
        "deploy:project:start",
        "deploy:start:project",
        "project:start:deploy",
        "start:project:deploy",
        "start:deploy:project"
      ]
    },
    "project:deploy:validate": {
      "aliases": [
        "deploy:metadata:validate"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Use this command to verify whether a deployment will succeed without actually deploying the metadata to your org. This command is similar to \"<%= config.bin %> project deploy start\", except you're required to run Apex tests, and the command returns a job ID rather than executing the deployment. If the validation succeeds, then you pass this job ID to the \"<%= config.bin %> project deploy quick\" command to actually deploy the metadata. This quick deploy takes less time because it skips running Apex tests. The job ID is valid for 10 days from when you started the validation. Validating first is useful if the deployment to your production org take several hours and you don’t want to risk a failed deploy.\n\nYou must run this command from within a project.\n\nThis command doesn't support source-tracking. When you quick deploy with the resulting job ID, the source you deploy overwrites the corresponding metadata in your org.\n\nTo validate the deployment of multiple metadata components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.\n\nNote: Don't use this command on sandboxes; the command is intended to be used on production orgs. By default, sandboxes don't run tests during a deploy. If you want to validate a deployment with tests on a sandbox, use \"<%= config.bin %> project deploy start --dry-run --test-level RunLocalTests\" instead.",
      "examples": [
        "NOTE: These examples focus on validating large deployments. See the help for \"<%= config.bin %> project deploy start\" for examples of deploying smaller sets of metadata which you can also use to validate.",
        "Validate the deployment of all source files in the \"force-app\" directory to the default org:\n<%= config.bin %> <%= command.id %> --source-dir force-app",
        "Validate the deployment of all source files in two directories: \"force-app\" and \"force-app-utils\":\n<%= config.bin %> <%= command.id %> --source-dir force-app --source-dir force-app-utils",
        "Asynchronously validate the deployment and run all tests in the org with alias \"my-prod-org\"; command immediately returns the job ID:\n<%= config.bin %> <%= command.id %> --source-dir force-app --async --test-level RunAllTestsInOrg --target-org my-prod-org",
        "Validate the deployment of all components listed in a manifest:\n<%= config.bin %> <%= command.id %> --manifest path/to/package.xml"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "char": "a",
          "description": "Use this flag to override the default API version with the API version of your package.xml file. The default API version is the latest version supported by the CLI.",
          "name": "api-version",
          "summary": "Target API version for the validation.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "async": {
          "description": "The command immediately returns the job ID and control of the terminal to you. This way, you can continue to use the CLI. To resume watching the validation, run \"<%= config.bin %> project deploy resume\". To check the status of the validation, run \"<%= config.bin %> project deploy report\".",
          "name": "async",
          "summary": "Run the command asynchronously.",
          "allowNo": false,
          "type": "boolean"
        },
        "concise": {
          "exclusive": [
            "verbose"
          ],
          "name": "concise",
          "summary": "Show concise output of the validation result.",
          "allowNo": false,
          "type": "boolean"
        },
        "manifest": {
          "char": "x",
          "description": "All child components are included. If you specify this flag, don’t specify --metadata or --source-dir.",
          "helpGroup": "Source Format",
          "name": "manifest",
          "summary": "Full file path for manifest (package.xml) of components to validate for deployment.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "helpGroup": "Source Format",
          "name": "metadata",
          "summary": "Metadata component names to validate for deployment.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "source-dir": {
          "char": "d",
          "description": "The supplied path can be to a single file (in which case the operation is applied to only one file) or to a folder (in which case the operation is applied to all metadata types in the directory and its subdirectories).\n\nIf you specify this flag, don’t specify --metadata or --manifest.",
          "helpGroup": "Source Format",
          "name": "source-dir",
          "summary": "Path to the local source files to validate for deployment.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "metadata-dir": {
          "helpGroup": "Metadata API Format",
          "name": "metadata-dir",
          "summary": "Root of directory or zip file of metadata formatted files to deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "single-package": {
          "dependsOn": [
            "metadata-dir"
          ],
          "helpGroup": "Metadata API Format",
          "name": "single-package",
          "summary": "Indicates that the metadata zip file points to a directory structure for a single package.",
          "allowNo": false,
          "type": "boolean"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "tests": {
          "char": "t",
          "description": "If a test name contains a space, enclose it in double quotes.\nFor multiple test names, use one of the following formats:\n\n- Repeat the flag for multiple test names: --tests Test1 --tests Test2 --tests \"Test With Space\"\n- Separate the test names with spaces: --tests Test1 Test2 \"Test With Space\"",
          "helpGroup": "Test",
          "name": "tests",
          "summary": "Apex tests to run when --test-level is RunSpecifiedTests.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "test-level": {
          "char": "l",
          "description": "Valid values are:\n\n- RunSpecifiedTests — Runs only the tests that you specify with the --tests flag. Code coverage requirements differ from the default coverage requirements when using this test level. Executed tests must comprise a minimum of 75% code coverage for each class and trigger in the deployment package. This coverage is computed for each class and trigger individually and is different than the overall coverage percentage.\n\n- RunLocalTests — All tests in your org are run, except the ones that originate from installed managed and unlocked packages. This test level is the default.\n\n- RunAllTestsInOrg — All tests in your org are run, including tests of managed packages.",
          "helpGroup": "Test",
          "name": "test-level",
          "summary": "Deployment Apex testing level.",
          "default": "RunLocalTests",
          "hasDynamicHelp": false,
          "multiple": false,
          "options": [
            "RunAllTestsInOrg",
            "RunLocalTests",
            "RunSpecifiedTests"
          ],
          "type": "option"
        },
        "verbose": {
          "exclusive": [
            "concise"
          ],
          "name": "verbose",
          "summary": "Show verbose output of the validation result.",
          "allowNo": false,
          "type": "boolean"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you and returns the job ID. To resume watching the validation, run \"<%= config.bin %> project deploy resume\". To check the status of the validation, run \"<%= config.bin %> project deploy report\".",
          "name": "wait",
          "summary": "Number of minutes to wait for the command to complete and display results.",
          "hasDynamicHelp": true,
          "helpValue": "<minutes>",
          "multiple": false,
          "type": "option"
        },
        "ignore-warnings": {
          "char": "g",
          "description": "If you specify this flag, and a warning occurs, the success status of the deployment is set to true. If you don't specify this flag, and a warning occurs, then the success status is set to false, and the warning is treated like an error.\n\nThis flag is useful in a CI environment and your deployment includes destructive changes; if you try to delete a component that doesn't exist in the org, you get a warning. In this case, to ensure that the command returns a success value of true, specify this flag.",
          "name": "ignore-warnings",
          "summary": "Ignore warnings and allow a deployment to complete successfully.",
          "allowNo": false,
          "type": "boolean"
        },
        "coverage-formatters": {
          "description": "For multiple formatters, repeat the flag for each formatter.\n--coverage-formatters lcov --coverage-formatters clover",
          "helpGroup": "Test",
          "name": "coverage-formatters",
          "summary": "Format of the code coverage results.",
          "hasDynamicHelp": false,
          "multiple": true,
          "options": [
            "clover",
            "cobertura",
            "html-spa",
            "html",
            "json",
            "json-summary",
            "lcovonly",
            "none",
            "teamcity",
            "text",
            "text-summary"
          ],
          "type": "option"
        },
        "junit": {
          "helpGroup": "Test",
          "name": "junit",
          "summary": "Output JUnit test results.",
          "allowNo": false,
          "type": "boolean"
        },
        "results-dir": {
          "helpGroup": "Test",
          "name": "results-dir",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "coverage-formatters",
                "junit"
              ]
            }
          ],
          "summary": "Output directory for code coverage and JUnit results; defaults to the deploy ID.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "purge-on-delete": {
          "dependsOn": [
            "manifest"
          ],
          "helpGroup": "Delete",
          "name": "purge-on-delete",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "pre-destructive-changes",
                "post-destructive-changes"
              ]
            }
          ],
          "summary": "Specify that deleted components in the destructive changes manifest file are immediately eligible for deletion rather than being stored in the Recycle Bin.",
          "allowNo": false,
          "type": "boolean"
        },
        "pre-destructive-changes": {
          "dependsOn": [
            "manifest"
          ],
          "helpGroup": "Delete",
          "name": "pre-destructive-changes",
          "summary": "File path for a manifest (destructiveChangesPre.xml) of components to delete before the deploy",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "post-destructive-changes": {
          "dependsOn": [
            "manifest"
          ],
          "helpGroup": "Delete",
          "name": "post-destructive-changes",
          "summary": "File path for a manifest (destructiveChangesPost.xml) of components to delete after the deploy.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:deploy:validate",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Validate a metadata deployment without actually executing it.",
      "enableJsonFlag": true,
      "configurationVariablesSection": {
        "header": "CONFIGURATION VARIABLES",
        "body": [
          {
            "name": "target-org",
            "description": "Username or alias of the org that all commands run against by default. (sf only)"
          },
          {
            "name": "org-api-version",
            "description": "API version of your project. Default: API version of your Dev Hub org."
          }
        ]
      },
      "envVariablesSection": {
        "header": "ENVIRONMENT VARIABLES",
        "body": [
          {
            "name": "SF_TARGET_ORG",
            "description": "Username or alias of your default org. Overrides the target-org configuration variable."
          },
          {
            "name": "SF_USE_PROGRESS_BAR",
            "description": "Set to false to disable the progress bar when running the metadata deploy command."
          }
        ]
      },
      "errorCodes": {
        "header": "ERROR CODES",
        "body": [
          {
            "name": "Succeeded (0)",
            "description": "The deploy succeeded."
          },
          {
            "name": "Canceled (1)",
            "description": "The deploy was canceled."
          },
          {
            "name": "Failed (1)",
            "description": "The deploy failed."
          },
          {
            "name": "SucceededPartial (68)",
            "description": "The deploy partially succeeded."
          },
          {
            "name": "InProgress (69)",
            "description": "The deploy is in progress."
          },
          {
            "name": "Pending (69)",
            "description": "The deploy is pending."
          },
          {
            "name": "Canceling (69)",
            "description": "The deploy is being canceled."
          }
        ]
      },
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "deploy",
        "validate.js"
      ],
      "aliasPermutations": [
        "deploy:metadata:validate",
        "metadata:deploy:validate",
        "metadata:validate:deploy",
        "deploy:validate:metadata",
        "validate:deploy:metadata",
        "validate:metadata:deploy"
      ],
      "permutations": [
        "project:deploy:validate",
        "deploy:project:validate",
        "deploy:validate:project",
        "project:validate:deploy",
        "validate:project:deploy",
        "validate:deploy:project"
      ]
    },
    "project:generate:manifest": {
      "aliases": [
        "force:source:manifest:create"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "Create a manifest from a list of metadata components (--metadata) or from one or more local directories that contain source files (--source-dir). You can specify either of these parameters, not both.\n\nUse --type to specify the type of manifest you want to create. The resulting manifest files have specific names, such as the standard package.xml or destructiveChanges.xml to delete metadata. Valid values for this parameter, and their respective file names, are:\n\n    * package : package.xml (default)\n    * pre : destructiveChangesPre.xml\n    * post : destructiveChangesPost.xml\n    * destroy : destructiveChanges.xml\n\nSee https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_deploy_deleting_files.htm for information about these destructive manifest files.\n\nUse --name to specify a custom name for the generated manifest if the pre-defined ones don’t suit your needs. You can specify either --type or --name, but not both.\n\nTo include multiple metadata components, either set multiple --metadata <name> flags or a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --include-packages and --source-dir.",
      "examples": [
        "Create a manifest for deploying or retrieving all Apex classes and custom objects:\n$ <%= config.bin %> <%= command.id %> --metadata ApexClass --metadata CustomObject",
        "Create a manifest for deleting the specified Apex class:\n$ <%= config.bin %> <%= command.id %> --metadata ApexClass:MyApexClass --type destroy",
        "Create a manifest for deploying or retrieving all the metadata components in the specified local directory; name the file myNewManifest.xml:\n$ <%= config.bin %> <%= command.id %> --source-dir force-app --name myNewManifest",
        "Create a manifest from the metadata components in the specified org and include metadata in any unlocked packages:\n$ <%= config.bin %> <%= command.id %> --from-org test@myorg.com --include-packages unlocked"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "aliases": [
            "apiversion"
          ],
          "deprecateAliases": true,
          "description": "Override the api version used for api requests made by this command",
          "name": "api-version",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "loglevel": {
          "deprecated": {
            "message": "The loglevel flag is no longer in use on this command. You may use it without error, but it will be ignored.\nSet the log level using the `SFDX_LOG_LEVEL` environment variable."
          },
          "hidden": true,
          "name": "loglevel",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "name": "metadata",
          "summary": "Names of metadata components to include in the manifest.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "source-dir": {
          "aliases": [
            "sourcepath"
          ],
          "char": "p",
          "deprecateAliases": true,
          "name": "source-dir",
          "summary": "Paths to the local source files to include in the manifest.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "name": {
          "aliases": [
            "manifestname"
          ],
          "char": "n",
          "deprecateAliases": true,
          "exclusive": [
            "type"
          ],
          "name": "name",
          "summary": "Name of a custom manifest file to create.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "type": {
          "aliases": [
            "manifesttype"
          ],
          "char": "t",
          "deprecateAliases": true,
          "exclusive": [
            "name"
          ],
          "name": "type",
          "summary": "Type of manifest to create; the type determines the name of the created file.",
          "hasDynamicHelp": false,
          "multiple": false,
          "options": [
            "pre",
            "post",
            "destroy",
            "package"
          ],
          "type": "option"
        },
        "include-packages": {
          "aliases": [
            "includepackages"
          ],
          "char": "c",
          "dependsOn": [
            "from-org"
          ],
          "deprecateAliases": true,
          "name": "include-packages",
          "summary": "Package types (managed, unlocked) whose metadata is included in the manifest; by default, metadata in managed and unlocked packages is excluded. Metadata in unmanaged packages is always included.",
          "delimiter": ",",
          "hasDynamicHelp": false,
          "multiple": true,
          "options": [
            "managed",
            "unlocked"
          ],
          "type": "option"
        },
        "from-org": {
          "aliases": [
            "fromorg"
          ],
          "deprecateAliases": true,
          "name": "from-org",
          "summary": "Username or alias of the org that contains the metadata components from which to build a manifest.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "output-dir": {
          "aliases": [
            "outputdir",
            "o"
          ],
          "char": "d",
          "deprecateAliases": true,
          "name": "output-dir",
          "summary": "Directory to save the created manifest.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": false,
      "hiddenAliases": [],
      "id": "project:generate:manifest",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Create a project manifest that lists the metadata components you want to deploy or retrieve.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "generate",
        "manifest.js"
      ],
      "aliasPermutations": [
        "force:source:manifest:create",
        "source:force:manifest:create",
        "source:manifest:force:create",
        "source:manifest:create:force",
        "force:manifest:source:create",
        "manifest:force:source:create",
        "manifest:source:force:create",
        "manifest:source:create:force",
        "force:manifest:create:source",
        "manifest:force:create:source",
        "manifest:create:force:source",
        "manifest:create:source:force",
        "force:source:create:manifest",
        "source:force:create:manifest",
        "source:create:force:manifest",
        "source:create:manifest:force",
        "force:create:source:manifest",
        "create:force:source:manifest",
        "create:source:force:manifest",
        "create:source:manifest:force",
        "force:create:manifest:source",
        "create:force:manifest:source",
        "create:manifest:force:source",
        "create:manifest:source:force"
      ],
      "permutations": [
        "project:generate:manifest",
        "generate:project:manifest",
        "generate:manifest:project",
        "project:manifest:generate",
        "manifest:project:generate",
        "manifest:generate:project"
      ]
    },
    "project:list:ignored": {
      "aliases": [
        "force:source:ignored:list"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "When deploying or retrieving metadata between your local project and an org, you can specify the source files you want to exclude with a .forceignore file. The .forceignore file structure mimics the .gitignore structure. Each line in .forceignore specifies a pattern that corresponds to one or more files. The files typically represent metadata components, but can be any files you want to exclude, such as LWC configuration JSON files or tests.",
      "examples": [
        "List all the files in all package directories that are ignored:\n<%= config.bin %> <%= command.id %>",
        "List all the files in a specific directory that are ignored:\n<%= config.bin %> <%= command.id %> --source-dir force-app",
        "Check if a particular file is ignored:\n<%= config.bin %> <%= command.id %> --source-dir package.xml"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "source-dir": {
          "aliases": [
            "sourcepath"
          ],
          "char": "p",
          "deprecateAliases": true,
          "name": "source-dir",
          "summary": "File or directory of files that the command checks for foreceignored files.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": false,
      "hiddenAliases": [],
      "id": "project:list:ignored",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Check your local project package directories for forceignored files.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "list",
        "ignored.js"
      ],
      "aliasPermutations": [
        "force:source:ignored:list",
        "source:force:ignored:list",
        "source:ignored:force:list",
        "source:ignored:list:force",
        "force:ignored:source:list",
        "ignored:force:source:list",
        "ignored:source:force:list",
        "ignored:source:list:force",
        "force:ignored:list:source",
        "ignored:force:list:source",
        "ignored:list:force:source",
        "ignored:list:source:force",
        "force:source:list:ignored",
        "source:force:list:ignored",
        "source:list:force:ignored",
        "source:list:ignored:force",
        "force:list:source:ignored",
        "list:force:source:ignored",
        "list:source:force:ignored",
        "list:source:ignored:force",
        "force:list:ignored:source",
        "list:force:ignored:source",
        "list:ignored:force:source",
        "list:ignored:source:force"
      ],
      "permutations": [
        "project:list:ignored",
        "list:project:ignored",
        "list:ignored:project",
        "project:ignored:list",
        "ignored:project:list",
        "ignored:list:project"
      ]
    },
    "project:reset:tracking": {
      "aliases": [
        "force:source:tracking:reset"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "WARNING: This command deletes or overwrites all existing source tracking files. Use with extreme caution.\n\nResets local and remote source tracking so that Salesforce CLI no longer registers differences between your local files and those in the org. When you next run 'project deploy preview', Salesforce CLI returns no results, even though conflicts might actually exist. Salesforce CLI then resumes tracking new source changes as usual.\n\nUse the --revision parameter to reset source tracking to a specific revision number of an org source member. To get the revision number, query the SourceMember Tooling API object with the 'data soql' command. For example:\n\n    <%= config.bin %> data query --query \"SELECT MemberName, MemberType, RevisionCounter FROM SourceMember\" --use-tooling-api --target-org my-scratch",
      "examples": [
        "Reset source tracking for the org with alias \"my-scratch\":\n$ <%= config.bin %> <%= command.id %> --target-org my-scratch",
        "Reset source tracking to revision number 30 for your default org:\n$ <%= config.bin %> <%= command.id %> --revision 30"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "aliases": [
            "targetusername",
            "u"
          ],
          "char": "o",
          "deprecateAliases": true,
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "aliases": [
            "apiversion"
          ],
          "deprecateAliases": true,
          "description": "Override the api version used for api requests made by this command",
          "name": "api-version",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "loglevel": {
          "deprecated": {
            "message": "The loglevel flag is no longer in use on this command. You may use it without error, but it will be ignored.\nSet the log level using the `SFDX_LOG_LEVEL` environment variable."
          },
          "hidden": true,
          "name": "loglevel",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "revision": {
          "char": "r",
          "name": "revision",
          "summary": "SourceMember revision counter number to reset to.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "no-prompt": {
          "aliases": [
            "noprompt"
          ],
          "char": "p",
          "deprecateAliases": true,
          "name": "no-prompt",
          "summary": "Don't prompt for source tracking override confirmation.",
          "allowNo": false,
          "type": "boolean"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:reset:tracking",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Reset local and remote source tracking.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "reset",
        "tracking.js"
      ],
      "aliasPermutations": [
        "force:source:tracking:reset",
        "source:force:tracking:reset",
        "source:tracking:force:reset",
        "source:tracking:reset:force",
        "force:tracking:source:reset",
        "tracking:force:source:reset",
        "tracking:source:force:reset",
        "tracking:source:reset:force",
        "force:tracking:reset:source",
        "tracking:force:reset:source",
        "tracking:reset:force:source",
        "tracking:reset:source:force",
        "force:source:reset:tracking",
        "source:force:reset:tracking",
        "source:reset:force:tracking",
        "source:reset:tracking:force",
        "force:reset:source:tracking",
        "reset:force:source:tracking",
        "reset:source:force:tracking",
        "reset:source:tracking:force",
        "force:reset:tracking:source",
        "reset:force:tracking:source",
        "reset:tracking:force:source",
        "reset:tracking:source:force"
      ],
      "permutations": [
        "project:reset:tracking",
        "reset:project:tracking",
        "reset:tracking:project",
        "project:tracking:reset",
        "tracking:project:reset",
        "tracking:reset:project"
      ]
    },
    "project:retrieve:preview": {
      "aliases": [
        "retrieve:metadata:preview"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "You must run this command from within a project.\n\nThe command outputs a table that describes what will happen if you run the \"<%= config.bin %> project retrieve start\" command. The table lists the metadata components that will be retrieved and deleted. The table also lists the current conflicts between files in your local project and components in the org. Finally, the table lists the files that won't be retrieved because they're included in your .forceignore file.\n\nIf your org allows source tracking, then this command displays potential conflicts between the org and your local project. Some orgs, such as production org, never allow source tracking. Source tracking is enabled by default on scratch and sandbox orgs; you can disable source tracking when you create the orgs by specifying the --no-track-source flag on the \"<%= config.bin %> org create scratch|sandbox\" commands.",
      "examples": [
        "Preview the retrieve of all changes from your default org:\n<%= config.bin %> <%= command.id %>",
        "Preview the retrieve when ignoring any conflicts from an org with alias \"my-scratch\":\n<%= config.bin %> <%= command.id %> --ignore-conflicts --target-org my-scratch"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "ignore-conflicts": {
          "char": "c",
          "description": "This flag applies only to orgs that allow source tracking. It has no effect on orgs that don't allow it, such as production orgs.",
          "name": "ignore-conflicts",
          "summary": "Don't display conflicts in the preview of the retrieval.",
          "allowNo": false,
          "type": "boolean"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "concise": {
          "name": "concise",
          "summary": "Show only the changes that will be retrieved; omits files that are forceignored.",
          "allowNo": false,
          "type": "boolean"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:retrieve:preview",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Preview a retrieval to see what will be retrieved from the org, the potential conflicts, and the ignored files.",
      "enableJsonFlag": true,
      "requiresProject": true,
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "retrieve",
        "preview.js"
      ],
      "aliasPermutations": [
        "retrieve:metadata:preview",
        "metadata:retrieve:preview",
        "metadata:preview:retrieve",
        "retrieve:preview:metadata",
        "preview:retrieve:metadata",
        "preview:metadata:retrieve"
      ],
      "permutations": [
        "project:retrieve:preview",
        "retrieve:project:preview",
        "retrieve:preview:project",
        "project:preview:retrieve",
        "preview:project:retrieve",
        "preview:retrieve:project"
      ]
    },
    "project:retrieve:start": {
      "aliases": [
        "retrieve:metadata"
      ],
      "args": {},
      "deprecateAliases": true,
      "description": "You must run this command from within a project.\n\nMetadata components are retrieved in source format by default. Retrieve them in metadata format by specifying the --target-metadata-dir flag, which retrieves the components into a ZIP file in the specified directory.\n\nIf your org allows source tracking, then this command tracks the changes in your source. Some orgs, such as production orgs, never allow source tracking. Source tracking is enabled by default on scratch and sandbox orgs; you can disable source tracking when you create the orgs by specifying the --no-track-source flag on the \"<%= config.bin %> org create scratch|sandbox\" commands.\n\nTo retrieve multiple metadata components, either use multiple --metadata <name> flags or use a single --metadata flag with multiple names separated by spaces. Enclose names that contain spaces in one set of double quotes. The same syntax applies to --manifest and --source-dir.",
      "examples": [
        "Retrieve all remote changes from your default org:\n<%= config.bin %> <%= command.id %>",
        "Retrieve the source files in the \"force-app\" directory from an org with alias \"my-scratch\":\n<%= config.bin %> <%= command.id %> --source-dir force-app --target-org my-scratch",
        "Retrieve all the Apex classes and custom objects whose source is in the \"force-app\" directory. The list views, layouts, etc, that are associated with the custom objects are also retrieved. Both examples are equivalent:\n<%= config.bin %> <%= command.id %> --source-dir force-app/main/default/classes force-app/main/default/objects\n<%= config.bin %> <%= command.id %> --source-dir force-app/main/default/classes --source-dir force-app/main/default/objects",
        "Retrieve all Apex classes that are in all package directories defined in the \"sfdx-project.json\" file:\n<%= config.bin %> <%= command.id %> --metadata ApexClass",
        "Retrieve a specific Apex class; ignore any conflicts between the local project and org (be careful with this flag, because it will overwrite the Apex class source files in your local project if there are conflicts!):\n<%= config.bin %> <%= command.id %> --metadata ApexClass:MyApexClass --ignore-conflicts",
        "Retrieve specific Apex classes that match a pattern; in this example, retrieve Apex classes whose names contain the string \"MyApex\":\n<%= config.bin %> <%= command.id %> --metadata 'ApexClass:MyApex*'",
        "Retrieve a custom object called ExcitingObject that's in the SBQQ namespace:\nsf <%= command.id %> --metadata CustomObject:SBQQ__ExcitingObject",
        "Retrieve all custom objects in the SBQQ namespace by using a wildcard and quotes:\nsf <%= command.id %> --metadata 'CustomObject:SBQQ__*'",
        "Retrieve all custom objects and Apex classes found in all defined package directories (both examples are equivalent):\n<%= config.bin %> <%= command.id %> --metadata CustomObject ApexClass\n<%= config.bin %> <%= command.id %> --metadata CustomObject --metadata ApexClass",
        "Retrieve all metadata components listed in a manifest:\n<%= config.bin %> <%= command.id %> --manifest path/to/package.xml",
        "Retrieve metadata from a package:\n<%= config.bin %> <%= command.id %> --package-name MyPackageName",
        "Retrieve metadata from multiple packages, one of which has a space in its name (both examples are equivalent):\n<%= config.bin %> <%= command.id %> --package-name Package1 \"PackageName With Spaces\" Package3\n<%= config.bin %> <%= command.id %> --package-name Package1 --package-name \"PackageName With Spaces\" --package-name Package3",
        "Retrieve the metadata components listed in the force-app directory, but retrieve them in metadata format into a ZIP file in the \"output\" directory:\n<%= config.bin %> <%= command.id %> --source-dir force-app --target-metadata-dir output",
        "Retrieve in metadata format and automatically extract the contents into the \"output\" directory:\n<%= config.bin %> <%= command.id %> --source-dir force-app --target-metadata-dir output --unzip"
      ],
      "flags": {
        "json": {
          "description": "Format output as json.",
          "helpGroup": "GLOBAL",
          "name": "json",
          "allowNo": false,
          "type": "boolean"
        },
        "flags-dir": {
          "helpGroup": "GLOBAL",
          "name": "flags-dir",
          "summary": "Import flag values from a directory.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "api-version": {
          "char": "a",
          "description": "Use this flag to override the default API version, which is the latest version supported the CLI, with the API version in your package.xml file.",
          "name": "api-version",
          "summary": "Target API version for the retrieve.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "ignore-conflicts": {
          "char": "c",
          "description": "This flag applies only to orgs that allow source tracking. It has no effect on orgs that don't allow it, such as production orgs.",
          "name": "ignore-conflicts",
          "summary": "Ignore conflicts and retrieve and save files to your local filesystem, even if they overwrite your local changes.",
          "allowNo": false,
          "type": "boolean"
        },
        "manifest": {
          "char": "x",
          "description": "If you specify this parameter, don’t specify --metadata or --source-dir.",
          "exclusive": [
            "metadata",
            "source-dir"
          ],
          "name": "manifest",
          "summary": "File path for the manifest (package.xml) that specifies the components to retrieve.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "metadata": {
          "char": "m",
          "exclusive": [
            "manifest",
            "source-dir"
          ],
          "name": "metadata",
          "summary": "Metadata component names to retrieve. Wildcards (`*`) supported as long as you use quotes, such as `ApexClass:MyClass*`.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "package-name": {
          "char": "n",
          "description": "The metadata of the supplied package name(s) will be retrieved into a child directory of the project. The name of that child directory matches the name of the package. The retrieved metadata is meant for your reference only, don't add it to a source control system for development and deployment. For package development, retrieve the metadata using a manifest (`--manifest` flag) or by targeting a source controlled package directory within your project (`--source-dir` flag).",
          "name": "package-name",
          "summary": "Package names to retrieve. Use of this flag is for reference only; don't use it to retrieve packaged metadata for development.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "output-dir": {
          "char": "r",
          "description": "The root of the directory structure into which the source files are retrieved.\nIf the target directory matches one of the package directories in your sfdx-project.json file, the command fails.\nRunning the command multiple times with the same target adds new files and overwrites existing files.",
          "exclusive": [
            "package-name",
            "source-dir"
          ],
          "name": "output-dir",
          "summary": "Directory root for the retrieved source files.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "single-package": {
          "dependsOn": [
            "target-metadata-dir"
          ],
          "exclusive": [
            "ignore-conflicts"
          ],
          "helpGroup": "Metadata API Format",
          "name": "single-package",
          "summary": "Indicates that the zip file points to a directory structure for a single package.",
          "allowNo": false,
          "type": "boolean"
        },
        "source-dir": {
          "char": "d",
          "description": "The supplied paths can be to a single file (in which case the operation is applied to only one file) or to a folder (in which case the operation is applied to all source files in the directory and its subdirectories).",
          "exclusive": [
            "manifest",
            "metadata"
          ],
          "name": "source-dir",
          "summary": "File paths for source to retrieve from the org.",
          "hasDynamicHelp": false,
          "multiple": true,
          "type": "option"
        },
        "target-metadata-dir": {
          "char": "t",
          "exclusive": [
            "ignore-conflicts"
          ],
          "helpGroup": "Metadata API Format",
          "name": "target-metadata-dir",
          "relationships": [
            {
              "type": "some",
              "flags": [
                "manifest",
                "metadata",
                "source-dir",
                "package-name"
              ]
            }
          ],
          "summary": "Directory that will contain the retrieved metadata format files or ZIP.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        },
        "target-org": {
          "char": "o",
          "name": "target-org",
          "noCacheDefault": true,
          "required": true,
          "summary": "Username or alias of the target org. Not required if the `target-org` configuration variable is already set.",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "wait": {
          "char": "w",
          "description": "If the command continues to run after the wait period, the CLI returns control of the terminal window to you.",
          "name": "wait",
          "summary": "Number of minutes to wait for the command to complete and display results to the terminal window.",
          "default": "33 minutes",
          "hasDynamicHelp": true,
          "multiple": false,
          "type": "option"
        },
        "unzip": {
          "char": "z",
          "dependsOn": [
            "target-metadata-dir"
          ],
          "exclusive": [
            "ignore-conflicts"
          ],
          "helpGroup": "Metadata API Format",
          "name": "unzip",
          "summary": "Extract all files from the retrieved zip file.",
          "allowNo": false,
          "type": "boolean"
        },
        "zip-file-name": {
          "dependsOn": [
            "target-metadata-dir"
          ],
          "exclusive": [
            "ignore-conflicts"
          ],
          "helpGroup": "Metadata API Format",
          "name": "zip-file-name",
          "summary": "File name to use for the retrieved zip file.",
          "hasDynamicHelp": false,
          "multiple": false,
          "type": "option"
        }
      },
      "hasDynamicHelp": true,
      "hiddenAliases": [],
      "id": "project:retrieve:start",
      "pluginAlias": "@salesforce/plugin-deploy-retrieve",
      "pluginName": "@salesforce/plugin-deploy-retrieve",
      "pluginType": "core",
      "strict": true,
      "summary": "Retrieve metadata from an org to your local project.",
      "enableJsonFlag": true,
      "configurationVariablesSection": {
        "header": "CONFIGURATION VARIABLES",
        "body": [
          {
            "name": "target-org",
            "description": "Username or alias of the org that all commands run against by default. (sf only)"
          },
          {
            "name": "org-api-version",
            "description": "API version of your project. Default: API version of your Dev Hub org."
          }
        ]
      },
      "envVariablesSection": {
        "header": "ENVIRONMENT VARIABLES",
        "body": [
          {
            "name": "SF_TARGET_ORG",
            "description": "Username or alias of your default org. Overrides the target-org configuration variable."
          },
          {
            "name": "SF_USE_PROGRESS_BAR",
            "description": "Set to false to disable the progress bar when running the metadata deploy command."
          }
        ]
      },
      "isESM": true,
      "relativePath": [
        "lib",
        "commands",
        "project",
        "retrieve",
        "start.js"
      ],
      "aliasPermutations": [
        "retrieve:metadata",
        "metadata:retrieve"
      ],
      "permutations": [
        "project:retrieve:start",
        "retrieve:project:start",
        "retrieve:start:project",
        "project:start:retrieve",
        "start:project:retrieve",
        "start:retrieve:project"
      ]
    }
  },
  "version": "3.12.0"
}