"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("fs");
const promises_1 = require("node:fs/promises");
const path = require("path");
const utils_1 = require("../utils");
const baseGenerator_1 = require("./baseGenerator");
const GITIGNORE = 'gitignore';
const HUSKY_FOLDER = '.husky';
const huskyhookarray = ['pre-commit'];
const vscodearray = ['extensions', 'launch', 'settings'];
const standardfolderarray = [
    'applications',
    'aura',
    'classes',
    'contentassets',
    'flexipages',
    'layouts',
    'objects',
    'permissionsets',
    'staticresources',
    'tabs',
    'triggers',
];
const filestocopy = [
    '.forceignore',
    GITIGNORE,
    '.prettierignore',
    '.prettierrc',
    'jest.config.js',
    'package.json',
];
const emptyfolderarray = ['aura', 'lwc'];
const analyticsfolderarray = ['aura', 'classes', 'lwc', 'waveTemplates'];
const analyticsVscodeExt = 'salesforce.analyticsdx-vscode';
function extendJSON(filepath, replacer) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const originalContent = JSON.parse(yield (0, promises_1.readFile)(filepath, 'utf8').catch(() => '{}'));
        const newContent = JSON.stringify(originalContent, replacer, 2);
        yield (0, promises_1.writeFile)(filepath, newContent);
    });
}
class ProjectGenerator extends baseGenerator_1.BaseGenerator {
    constructor(options) {
        super(options);
        this.sourceRootWithPartialPath('project');
    }
    validateOptions() {
        utils_1.CreateUtil.checkInputs(this.options.template);
    }
    generate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { projectname, template, defaultpackagedir, manifest, ns, loginurl } = this.options;
            const folderlayout = [
                this.outputdir,
                projectname,
                defaultpackagedir,
                'main',
                'default',
            ];
            const scratchDefFile = `${template}/ScratchDef.json`;
            const manifestFile = `${template}/Manifest.xml`;
            const soqlQueryFile = 'account.soql';
            const anonApexFile = 'hello.apex';
            yield this.render(this.templatePath(scratchDefFile), this.destinationPath(path.join(this.outputdir, projectname, 'config', 'project-scratch-def.json')), { company: (process.env.USER || 'Demo') + ' company' });
            yield this.render(this.templatePath(`${template}/README.md`), this.destinationPath(path.join(this.outputdir, projectname, 'README.md')), {});
            yield this.render(this.templatePath('sfdx-project.json'), this.destinationPath(path.join(this.outputdir, projectname, 'sfdx-project.json')), {
                defaultpackagedir,
                namespace: ns,
                loginurl,
                apiversion: this.apiversion,
                name: projectname,
            });
            if (manifest === true) {
                yield this.render(this.templatePath(manifestFile), this.destinationPath(path.join(this.outputdir, projectname, 'manifest', 'package.xml')), { apiversion: this.apiversion });
            }
            if (template === 'standard') {
                yield makeEmptyFolders(folderlayout, standardfolderarray);
                // Add Husky directory and hooks
                this._createHuskyConfig(path.join(this.outputdir, projectname));
                for (const file of vscodearray) {
                    yield this.render(this.templatePath(`${file}.json`), this.destinationPath(path.join(this.outputdir, projectname, '.vscode', `${file}.json`)), {});
                }
                yield this.render(this.templatePath('lwc.eslintrc.json'), this.destinationPath(path.join(...folderlayout, 'lwc', '.eslintrc.json')), {});
                yield this.render(this.templatePath('aura.eslintrc.json'), this.destinationPath(path.join(...folderlayout, 'aura', '.eslintrc.json')), {});
                yield this.render(this.templatePath(path.join(template, soqlQueryFile)), this.destinationPath(path.join(this.outputdir, projectname, 'scripts', 'soql', soqlQueryFile)), {});
                yield this.render(this.templatePath(path.join(template, anonApexFile)), this.destinationPath(path.join(this.outputdir, projectname, 'scripts', 'apex', anonApexFile)), {});
                for (const file of filestocopy) {
                    const out = file === GITIGNORE ? `.${file}` : file;
                    yield this.render(this.templatePath(file), this.destinationPath(path.join(this.outputdir, projectname, out)), {});
                }
            }
            if (template === 'empty') {
                yield makeEmptyFolders(folderlayout, emptyfolderarray);
                yield this.render(this.templatePath('.forceignore'), this.destinationPath(path.join(this.outputdir, projectname, '.forceignore')), {});
            }
            if (template === 'analytics') {
                yield makeEmptyFolders(folderlayout, analyticsfolderarray);
                // Add Husky directory and hooks
                this._createHuskyConfig(path.join(this.outputdir, projectname));
                for (const file of vscodearray) {
                    yield this.render(this.templatePath(`${file}.json`), this.destinationPath(path.join(this.outputdir, projectname, '.vscode', `${file}.json`)), {});
                }
                // add the analytics vscode extension to the recommendations
                yield extendJSON(path.join(this.outputdir, projectname, '.vscode', 'extensions.json'), (key, value) => {
                    if (key === 'recommendations' &&
                        Array.isArray(value) &&
                        !value.some((n) => n === analyticsVscodeExt)) {
                        value.push(analyticsVscodeExt);
                    }
                    return value;
                });
                yield this.render(this.templatePath('lwc.eslintrc.json'), this.destinationPath(path.join(...folderlayout, 'lwc', '.eslintrc.json')), {});
                yield this.render(this.templatePath('aura.eslintrc.json'), this.destinationPath(path.join(...folderlayout, 'aura', '.eslintrc.json')), {});
                for (const file of filestocopy) {
                    const out = file === GITIGNORE ? `.${file}` : file;
                    yield this.render(this.templatePath(file), this.destinationPath(path.join(this.outputdir, projectname, out)), {});
                }
            }
        });
    }
    _createHuskyConfig(projectRootDir) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const huskyDirPath = path.join(projectRootDir, HUSKY_FOLDER);
            if (!fs.existsSync(huskyDirPath)) {
                fs.mkdirSync(huskyDirPath);
            }
            for (const file of huskyhookarray) {
                yield this.render(this.templatePath(path.join(HUSKY_FOLDER, file)), this.destinationPath(path.join(huskyDirPath, file)), {});
            }
        });
    }
}
exports.default = ProjectGenerator;
function makeEmptyFolders(toplevelfolders, metadatafolders) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        for (const folder of metadatafolders) {
            yield (0, promises_1.mkdir)(path.join(...toplevelfolders, folder), { recursive: true });
        }
    });
}
//# sourceMappingURL=projectGenerator.js.map