/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Flags, loglevel, SfCommand } from '@salesforce/sf-plugins-core';
import { AuthInfo, Messages, matchesAccessToken, SfError, StateAggregator } from '@salesforce/core';
import { env } from '@salesforce/kit';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-auth', 'accesstoken.store');
const commonMessages = Messages.loadMessages('@salesforce/plugin-auth', 'messages');
const ACCESS_TOKEN_FORMAT = '"<org id>!<accesstoken>"';
export default class LoginAccessToken extends SfCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static deprecateAliases = true;
    static aliases = ['force:auth:accesstoken:store', 'auth:accesstoken:store'];
    static flags = {
        'instance-url': Flags.url({
            char: 'r',
            summary: commonMessages.getMessage('flags.instance-url.summary'),
            description: commonMessages.getMessage('flags.instance-url.description'),
            required: true,
            deprecateAliases: true,
            aliases: ['instanceurl'],
        }),
        'set-default-dev-hub': Flags.boolean({
            char: 'd',
            summary: commonMessages.getMessage('flags.set-default-dev-hub.summary'),
            default: false,
            deprecateAliases: true,
            aliases: ['setdefaultdevhub', 'setdefaultdevhubusername'],
        }),
        'set-default': Flags.boolean({
            char: 's',
            summary: commonMessages.getMessage('flags.set-default.summary'),
            default: false,
            deprecateAliases: true,
            aliases: ['setdefaultusername'],
        }),
        alias: Flags.string({
            char: 'a',
            summary: commonMessages.getMessage('flags.alias.summary'),
            deprecateAliases: true,
            aliases: ['setalias'],
        }),
        'no-prompt': Flags.boolean({
            char: 'p',
            summary: commonMessages.getMessage('flags.no-prompt.summary'),
            required: false,
            default: false,
            deprecateAliases: true,
            aliases: ['noprompt'],
        }),
        loglevel,
    };
    flags;
    async run() {
        const { flags } = await this.parse(LoginAccessToken);
        this.flags = flags;
        const instanceUrl = flags['instance-url'].href;
        const accessToken = await this.getAccessToken();
        const authInfo = await this.getUserInfo(accessToken, instanceUrl);
        return this.storeAuthFromAccessToken(authInfo);
    }
    // because stubbed on the test (instead of stubbing in core)
    // eslint-disable-next-line class-methods-use-this
    async getUserInfo(accessToken, instanceUrl) {
        return AuthInfo.create({ accessTokenOptions: { accessToken, instanceUrl, loginUrl: instanceUrl } });
    }
    async storeAuthFromAccessToken(authInfo) {
        if (await this.overwriteAuthInfo(authInfo.getUsername())) {
            await this.saveAuthInfo(authInfo);
            const successMsg = commonMessages.getMessage('authorizeCommandSuccess', [
                authInfo.getUsername(),
                authInfo.getFields(true).orgId,
            ]);
            this.logSuccess(successMsg);
        }
        return authInfo.getFields(true);
    }
    async saveAuthInfo(authInfo) {
        await authInfo.save();
        await authInfo.handleAliasAndDefaultSettings({
            alias: this.flags.alias,
            setDefault: this.flags['set-default'],
            setDefaultDevHub: this.flags['set-default-dev-hub'],
        });
        await AuthInfo.identifyPossibleScratchOrgs(authInfo.getFields(true), authInfo);
    }
    async overwriteAuthInfo(username) {
        if (!this.flags['no-prompt']) {
            const stateAggregator = await StateAggregator.getInstance();
            if (await stateAggregator.orgs.exists(username)) {
                return this.confirm({ message: messages.getMessage('overwriteAccessTokenAuthUserFile', [username]) });
            }
        }
        return true;
    }
    async getAccessToken() {
        const accessToken = env.getString('SF_ACCESS_TOKEN') ??
            env.getString('SFDX_ACCESS_TOKEN') ??
            (this.flags['no-prompt'] === true
                ? '' // will throw when validating
                : await this.secretPrompt({ message: commonMessages.getMessage('accessTokenStdin') }));
        if (!matchesAccessToken(accessToken)) {
            throw new SfError(messages.getMessage('invalidAccessTokenFormat', [ACCESS_TOKEN_FORMAT]));
        }
        return accessToken;
    }
}
//# sourceMappingURL=access-token.js.map