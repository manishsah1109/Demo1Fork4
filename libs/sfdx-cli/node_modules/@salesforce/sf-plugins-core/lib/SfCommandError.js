/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { inspect } from 'node:util';
import { SfError } from '@salesforce/core';
import { computeErrorCode } from './errorHandling.js';
export class SfCommandError extends SfError {
    status;
    commandName;
    warnings;
    result;
    skipOclifErrorHandling;
    oclif;
    /**
     * SfCommandError is meant to wrap errors from `SfCommand.catch()` for a common
     * error format to be logged, sent to telemetry, and re-thrown. Do not create
     * instances from the constructor.  Call the static method, `SfCommandError.from()`
     * and use the returned `SfCommandError`.
     */
    constructor(input) {
        super(input.message, input.name, input.actions, input.exitCode, input.cause);
        this.data = input.data;
        this.status = input.exitCode;
        this.warnings = input.warnings;
        this.skipOclifErrorHandling = true;
        this.commandName = input.commandName;
        this.code = input.code;
        this.result = input.result;
        this.oclif = { exit: input.exitCode };
        this.context = input.context ?? input.commandName;
    }
    static from(err, commandName, warnings) {
        // SfError.wrap() does most of what we want so start with that.
        const sfError = SfError.wrap(err);
        const exitCode = computeErrorCode(err);
        return new this({
            message: sfError.message,
            name: err.name ?? 'Error',
            actions: 'actions' in err ? err.actions : undefined,
            exitCode,
            code: 'code' in err && err.code ? err.code : exitCode.toString(10),
            cause: sfError.cause,
            commandName: 'commandName' in err ? err.commandName : commandName,
            data: 'data' in err ? err.data : undefined,
            result: 'result' in err ? err.result : undefined,
            context: 'context' in err ? err.context : commandName,
            warnings,
        });
    }
    toJson() {
        return {
            // toObject() returns name, message, exitCode, actions, context, data
            ...this.toObject(),
            stack: this.stack,
            cause: inspect(this.cause),
            warnings: this.warnings,
            code: this.code,
            status: this.status,
            commandName: this.commandName,
            result: this.result,
        };
    }
    appendErrorSuggestions() {
        const output = 
        // @ts-expect-error error's causes aren't typed, this is what's returned from flag parsing errors
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        this.cause?.parse?.output?.raw ?? [];
        /*
         if there's a group of args, and additional args separated, we could have multiple suggestions
         --first my first --second my second =>
         try this:
         --first "my first"
         --second "my second"
        */
        const aggregator = [];
        output.forEach((k, i) => {
            let argCounter = i + 1;
            if (k.type === 'flag' && output[argCounter]?.type === 'arg') {
                const args = [];
                while (output[argCounter]?.type === 'arg') {
                    args.push(output[argCounter].input);
                    argCounter++;
                }
                aggregator.push({ flag: k.flag, args: [k.input, ...args] });
            }
        });
        this.actions ??= [];
        this.actions.push(...aggregator.map((cause) => `--${cause.flag} "${cause.args.join(' ')}"`));
    }
}
//# sourceMappingURL=SfCommandError.js.map