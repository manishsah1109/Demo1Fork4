"use strict";
/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HumanFormatTransform = void 0;
const tableWritableStream_1 = require("../utils/tableWritableStream");
const i18n_1 = require("../i18n");
const node_stream_1 = require("node:stream");
const utils_1 = require("../utils");
const core_1 = require("@salesforce/core");
class HumanFormatTransform extends node_stream_1.Readable {
    testResult;
    detailedCoverage;
    concise;
    logger;
    constructor(testResult, detailedCoverage, concise = false, options) {
        super(options);
        this.testResult = testResult;
        this.detailedCoverage = detailedCoverage;
        this.concise = concise;
        this.testResult = testResult;
        this.detailedCoverage ??= false;
        this.concise = concise;
        this.logger = core_1.Logger.childFromRoot('HumanFormatTransform');
    }
    _read() {
        this.logger.trace('starting _read');
        utils_1.HeapMonitor.getInstance().checkHeapSize('HumanFormatTransform._read');
        try {
            this.format();
            this.push(null); // Indicates end of data
            this.logger.trace('finishing _read');
        }
        finally {
            utils_1.HeapMonitor.getInstance().checkHeapSize('HumanFormatTransform._read');
        }
    }
    format() {
        if (!this.testResult.codecoverage || !this.detailedCoverage) {
            this.formatTestResults();
        }
        if (this.testResult.codecoverage) {
            if (this.detailedCoverage) {
                this.formatDetailedCov();
            }
            if (!this.concise) {
                this.formatCodeCov();
            }
        }
        if (this.testResult.setup && !this.concise) {
            this.formatSetup();
        }
        this.formatSummary();
    }
    formatSummary() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        // Summary Table
        const summaryRowArray = [
            {
                name: i18n_1.nls.localize('outcome'),
                value: this.testResult.summary.outcome
            },
            {
                name: i18n_1.nls.localize('testsRan'),
                value: String(this.testResult.summary.testsRan)
            },
            {
                name: i18n_1.nls.localize('passRate'),
                value: this.testResult.summary.passRate
            },
            {
                name: i18n_1.nls.localize('failRate'),
                value: this.testResult.summary.failRate
            },
            {
                name: i18n_1.nls.localize('skipRate'),
                value: this.testResult.summary.skipRate
            },
            {
                name: i18n_1.nls.localize('testRunId'),
                value: this.testResult.summary.testRunId
            },
            {
                name: i18n_1.nls.localize('testSetupTime'),
                value: `${this.testResult.summary.testSetupTimeInMs || 0} ms`
            },
            {
                name: i18n_1.nls.localize('testExecutionTime'),
                value: `${this.testResult.summary.testExecutionTimeInMs} ms`
            },
            {
                name: i18n_1.nls.localize('testTotalTime'),
                value: `${this.testResult.summary.testTotalTimeInMs} ms`
            },
            {
                name: i18n_1.nls.localize('orgId'),
                value: this.testResult.summary.orgId
            },
            {
                name: i18n_1.nls.localize('username'),
                value: this.testResult.summary.username
            },
            ...(this.testResult.summary.orgWideCoverage
                ? [
                    {
                        name: i18n_1.nls.localize('orgWideCoverage'),
                        value: String(this.testResult.summary.orgWideCoverage)
                    }
                ]
                : [])
        ];
        this.push(`\n\n`);
        tb.createTable(summaryRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('nameColHeader')
            },
            { key: 'value', label: i18n_1.nls.localize('valueColHeader') }
        ], i18n_1.nls.localize('testSummaryHeader'));
    }
    formatTestResults() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const testRowArray = [];
        this.testResult.tests.forEach((elem) => {
            if (!this.concise ||
                elem.outcome === "Fail" /* ApexTestResultOutcome.Fail */ ||
                elem.outcome === "CompileFail" /* ApexTestResultOutcome.CompileFail */) {
                const msg = elem.stackTrace
                    ? `${elem.message}\n${elem.stackTrace}`
                    : elem.message;
                testRowArray.push({
                    name: elem.fullName,
                    outcome: elem.outcome,
                    msg: elem.message ? msg : '',
                    runtime: elem.outcome !== "Fail" /* ApexTestResultOutcome.Fail */
                        ? `${elem.runTime}`
                        : ''
                });
            }
        });
        if (testRowArray.length > 0) {
            this.push('\n\n');
            tb.createTable(testRowArray, [
                {
                    key: 'name',
                    label: i18n_1.nls.localize('testNameColHeader')
                },
                { key: 'outcome', label: i18n_1.nls.localize('outcomeColHeader') },
                { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
                { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
            ], i18n_1.nls.localize('testResultsHeader'));
        }
    }
    formatSetup() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const testRowArray = [];
        this.testResult.setup.forEach((elem) => {
            testRowArray.push({
                name: elem.fullName,
                time: `${elem.testSetupTime}`,
                runId: this.testResult.summary.testRunId
            });
        });
        if (testRowArray.length > 0) {
            this.push('\n\n');
            tb.createTable(testRowArray, [
                {
                    key: 'name',
                    label: i18n_1.nls.localize('testSetupMethodNameColHeader')
                },
                { key: 'time', label: i18n_1.nls.localize('setupTimeColHeader') }
            ], i18n_1.nls
                .localize('testSetupResultsHeader')
                .replace('runId', testRowArray[0].runId));
        }
    }
    formatDetailedCov() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const testRowArray = [];
        this.testResult.tests.forEach((elem) => {
            if (!this.concise ||
                elem.outcome === "Fail" /* ApexTestResultOutcome.Fail */ ||
                elem.outcome === "CompileFail" /* ApexTestResultOutcome.CompileFail */) {
                const msg = elem.stackTrace
                    ? `${elem.message}\n${elem.stackTrace}`
                    : elem.message;
                if (elem.perClassCoverage) {
                    elem.perClassCoverage.forEach((perClassCov) => {
                        testRowArray.push({
                            name: elem.fullName,
                            coveredClassName: perClassCov.apexClassOrTriggerName,
                            outcome: elem.outcome,
                            coveredClassPercentage: perClassCov.percentage,
                            msg: elem.message ? msg : '',
                            runtime: `${elem.runTime}`
                        });
                    });
                }
                else {
                    testRowArray.push({
                        name: elem.fullName,
                        coveredClassName: '',
                        outcome: elem.outcome,
                        coveredClassPercentage: '',
                        msg: elem.message ? msg : '',
                        runtime: `${elem.runTime}`
                    });
                }
            }
        });
        if (testRowArray.length > 0) {
            this.push('\n\n'.repeat(2));
            tb.createTable(testRowArray, [
                {
                    key: 'name',
                    label: i18n_1.nls.localize('testNameColHeader')
                },
                {
                    key: 'coveredClassName',
                    label: i18n_1.nls.localize('classTestedHeader')
                },
                {
                    key: 'outcome',
                    label: i18n_1.nls.localize('outcomeColHeader')
                },
                {
                    key: 'coveredClassPercentage',
                    label: i18n_1.nls.localize('percentColHeader')
                },
                { key: 'msg', label: i18n_1.nls.localize('msgColHeader') },
                { key: 'runtime', label: i18n_1.nls.localize('runtimeColHeader') }
            ], i18n_1.nls.localize('detailedCodeCovHeader', [
                this.testResult.summary.testRunId
            ]));
        }
    }
    formatCodeCov() {
        const tb = new tableWritableStream_1.TableWriteableStream(this);
        const codeCovRowArray = [];
        this.testResult.codecoverage.forEach((elem) => {
            codeCovRowArray.push({
                name: elem.name,
                percent: elem.percentage,
                uncoveredLines: this.formatUncoveredLines(elem.uncoveredLines)
            });
        });
        this.push('\n\n'.repeat(2));
        tb.createTable(codeCovRowArray, [
            {
                key: 'name',
                label: i18n_1.nls.localize('classesColHeader')
            },
            {
                key: 'percent',
                label: i18n_1.nls.localize('percentColHeader')
            },
            {
                key: 'uncoveredLines',
                label: i18n_1.nls.localize('uncoveredLinesColHeader')
            }
        ], i18n_1.nls.localize('codeCovHeader'));
    }
    formatUncoveredLines(uncoveredLines) {
        const arrayLimit = 5;
        if (uncoveredLines.length === 0) {
            return '';
        }
        const limit = uncoveredLines.length > arrayLimit ? arrayLimit : uncoveredLines.length;
        let processedLines = uncoveredLines.slice(0, limit).join(',');
        if (uncoveredLines.length > arrayLimit) {
            processedLines += '...';
        }
        return processedLines;
    }
}
exports.HumanFormatTransform = HumanFormatTransform;
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "format", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatSummary", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatTestResults", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatSetup", null);
__decorate([
    (0, utils_1.elapsedTime)()
], HumanFormatTransform.prototype, "formatDetailedCov", null);
__decorate([
    (0, utils_1.elapsedTime)('elapsedTime', core_1.LoggerLevel.TRACE)
], HumanFormatTransform.prototype, "formatCodeCov", null);
__decorate([
    (0, utils_1.elapsedTime)('elapsedTime', core_1.LoggerLevel.TRACE)
], HumanFormatTransform.prototype, "formatUncoveredLines", null);
//# sourceMappingURL=humanFormatTransform.js.map