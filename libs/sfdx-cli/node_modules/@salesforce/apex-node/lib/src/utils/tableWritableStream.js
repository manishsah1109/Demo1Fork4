"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableWriteableStream = void 0;
const elapsedTime_1 = require("./elapsedTime");
const core_1 = require("@salesforce/core");
const COLUMN_SEPARATOR = ' '.repeat(2);
const COLUMN_FILLER = ' ';
const HEADER_FILLER = 'â”€';
class TableWriteableStream {
    stream;
    constructor(stream) {
        this.stream = stream;
        this.stream = stream;
    }
    createTable(rows, cols, title) {
        if (!rows) {
            throw Error('rows cannot be undefined');
        }
        if (!cols) {
            throw Error('columns cannot be undefined');
        }
        const maxColWidths = this.calculateMaxColumnWidths(rows, cols);
        let columnHeader = '';
        let headerSeparator = '';
        cols.forEach((col, index, arr) => {
            const width = maxColWidths.get(col.key);
            if (width) {
                const isLastCol = index === arr.length - 1;
                columnHeader += this.fillColumn(col.label || col.key, width, COLUMN_FILLER, isLastCol);
                headerSeparator += this.fillColumn('', width, HEADER_FILLER, isLastCol);
            }
        });
        if (columnHeader && headerSeparator) {
            this.stream.push(`${title ? `=== ${title}\n` : ''}${columnHeader}\n${headerSeparator}\n`);
        }
        rows.forEach((row) => {
            let outputRow = '';
            cols.forEach((col, colIndex, colArr) => {
                const cell = row[col.key];
                const isLastCol = colIndex === colArr.length - 1;
                const rowWidth = outputRow.length;
                cell.split('\n').forEach((line, lineIndex) => {
                    const cellWidth = maxColWidths.get(col.key);
                    if (cellWidth) {
                        if (lineIndex === 0) {
                            outputRow += this.fillColumn(line, cellWidth, COLUMN_FILLER, isLastCol);
                        }
                        else {
                            outputRow +=
                                '\n' +
                                    this.fillColumn('', rowWidth, COLUMN_FILLER, true) +
                                    this.fillColumn(line, cellWidth, COLUMN_FILLER, isLastCol);
                        }
                    }
                });
            });
            this.stream.push(outputRow + '\n');
            // this call to setImmediate will schedule the closure on the event loop
            // this action causing the current code to yield to the event loop
            // allowing other processes to get time on the event loop
            setImmediate(() => { });
        });
    }
    calculateMaxColumnWidths(rows, cols) {
        const maxColWidths = new Map();
        cols.forEach((col) => {
            rows.forEach((row) => {
                const cell = row[col.key];
                if (cell === undefined) {
                    throw Error(`Row is missing the key ${col.key}`);
                }
                let maxColWidth = maxColWidths.get(col.key);
                if (maxColWidth === undefined) {
                    maxColWidth = (col.label || col.key).length;
                    maxColWidths.set(col.key, maxColWidth);
                }
                // if a cell is multiline, find the line that's the longest
                const longestLineWidth = cell
                    .split('\n')
                    .reduce((maxLine, line) => line.length > maxLine.length ? line : maxLine).length;
                if (longestLineWidth > maxColWidth) {
                    maxColWidths.set(col.key, longestLineWidth);
                }
            });
        });
        return maxColWidths;
    }
    fillColumn(label, width, filler, isLastCol) {
        let filled = label;
        for (let i = 0; i < width - label.length; i++) {
            filled += filler;
        }
        if (!isLastCol) {
            filled += COLUMN_SEPARATOR;
        }
        return filled;
    }
}
exports.TableWriteableStream = TableWriteableStream;
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TableWriteableStream.prototype, "createTable", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TableWriteableStream.prototype, "calculateMaxColumnWidths", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)('elapsedTime', core_1.LoggerLevel.TRACE)
], TableWriteableStream.prototype, "fillColumn", null);
//# sourceMappingURL=tableWritableStream.js.map