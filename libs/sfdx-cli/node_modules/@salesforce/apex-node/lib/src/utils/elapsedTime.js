"use strict";
/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.elapsedTime = elapsedTime;
/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-return */
const core_1 = require("@salesforce/core");
const log = (level, logger, msg, properties = {}) => {
    if (!logger.shouldLog(level)) {
        return;
    }
    const payload = { msg, ...properties };
    switch (level) {
        case core_1.LoggerLevel.TRACE:
            logger.trace(payload);
            break;
        case core_1.LoggerLevel.DEBUG:
            logger.debug(payload);
            break;
        case core_1.LoggerLevel.INFO:
            logger.info(payload);
            break;
        case core_1.LoggerLevel.WARN:
            logger.warn(payload);
            break;
        case core_1.LoggerLevel.ERROR:
            logger.error(payload);
            break;
        case core_1.LoggerLevel.FATAL:
            logger.fatal(payload);
            break;
    }
};
/**
 * This decorator can be used to annotate functions in a class, so that the elapsed time
 * spent in the class can be sent to telemetry.
 *
 * @returns
 * @param loggerName - name of the child logger, defaults to 'elapsedTime'
 * @param level - log level - defaults to debug
 */
function elapsedTime(loggerName = 'elapsedTime', level = core_1.LoggerLevel.DEBUG) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const className = target.constructor.name;
        descriptor.value = function (...args) {
            const logger = core_1.Logger.childFromRoot(loggerName);
            const start = process.hrtime();
            log(level, logger, `${className}.${propertyKey} - enter`);
            let wrappedResult;
            let error;
            try {
                wrappedResult = originalMethod.apply(this, args);
            }
            catch (err) {
                error = err;
            }
            const handleResult = () => {
                const diff = process.hrtime(start);
                const elapsedTime = diff[0] * 1e3 + diff[1] / 1e6;
                log(level, logger, `${className}.${propertyKey} - exit`, {
                    elapsedTime
                });
            };
            if (wrappedResult instanceof Promise) {
                return wrappedResult
                    .then((results) => {
                    handleResult();
                    return results;
                })
                    .catch((e) => {
                    handleResult();
                    return Promise.reject(e);
                });
            }
            else {
                handleResult();
                if (error) {
                    throw error;
                }
                return wrappedResult;
            }
        };
        return descriptor;
    };
}
//# sourceMappingURL=elapsedTime.js.map