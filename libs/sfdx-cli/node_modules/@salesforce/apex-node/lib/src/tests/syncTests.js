"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncTests = void 0;
const utils_1 = require("../utils");
const codeCoverage_1 = require("./codeCoverage");
const diagnosticUtil_1 = require("./diagnosticUtil");
const utils_2 = require("./utils");
class SyncTests {
    connection;
    codecoverage;
    constructor(connection) {
        this.connection = connection;
        this.codecoverage = new codeCoverage_1.CodeCoverage(this.connection);
    }
    /**
     * Synchronous Test Runs
     * @param options Synchronous Test Runs configuration
     * @param codeCoverage should report code coverage
     * @param token cancellation token
     */
    async runTests(options, codeCoverage = false, token) {
        utils_1.HeapMonitor.getInstance().checkHeapSize('synctests.runTests');
        try {
            const url = `${this.connection.tooling._baseUrl()}/runTestsSynchronous`;
            const request = {
                method: 'POST',
                url,
                body: JSON.stringify(options),
                headers: { 'content-type': 'application/json' }
            };
            const testRun = (await this.connection.tooling.request(request));
            if (token?.isCancellationRequested) {
                return null;
            }
            return await this.formatSyncResults(testRun, (0, utils_1.getCurrentTime)(), codeCoverage);
        }
        catch (e) {
            throw (0, diagnosticUtil_1.formatTestErrors)(e);
        }
        finally {
            utils_1.HeapMonitor.getInstance().checkHeapSize('synctests.runTests');
        }
    }
    async formatSyncResults(apiTestResult, startTime, codeCoverage = false) {
        utils_1.HeapMonitor.getInstance().checkHeapSize('synctests.formatSyncResults');
        const { apexTestClassIdSet, testResults } = this.buildSyncTestResults(apiTestResult);
        try {
            const globalTestFailed = apiTestResult.failures.length;
            const globalTestPassed = apiTestResult.successes.length;
            const rawResult = {
                summary: {
                    outcome: globalTestFailed === 0
                        ? "Passed" /* ApexTestRunResultStatus.Passed */
                        : "Failed" /* ApexTestRunResultStatus.Failed */,
                    testsRan: apiTestResult.numTestsRun,
                    passing: globalTestPassed,
                    failing: globalTestFailed,
                    skipped: 0,
                    passRate: (0, utils_2.calculatePercentage)(globalTestPassed, apiTestResult.numTestsRun),
                    failRate: (0, utils_2.calculatePercentage)(globalTestFailed, apiTestResult.numTestsRun),
                    skipRate: (0, utils_2.calculatePercentage)(0, apiTestResult.numTestsRun),
                    testStartTime: (0, utils_1.formatStartTime)(startTime, 'ISO'),
                    testExecutionTimeInMs: apiTestResult.totalTime ?? 0,
                    testTotalTimeInMs: apiTestResult.totalTime ?? 0,
                    commandTimeInMs: (0, utils_1.getCurrentTime)() - startTime,
                    hostname: this.connection.instanceUrl,
                    orgId: this.connection.getAuthInfoFields().orgId,
                    username: this.connection.getUsername(),
                    testRunId: '',
                    userId: this.connection.getConnectionOptions().userId
                },
                tests: testResults
            };
            await (0, utils_2.calculateCodeCoverage)(this.codecoverage, codeCoverage, apexTestClassIdSet, rawResult, false);
            return (0, utils_2.transformTestResult)(rawResult);
        }
        finally {
            utils_1.HeapMonitor.getInstance().checkHeapSize('synctests.formatSyncResults');
        }
    }
    buildSyncTestResults(apiTestResult) {
        utils_1.HeapMonitor.getInstance().checkHeapSize('syncTests.buildSyncTestResults');
        try {
            const apexTestClassIdSet = new Set();
            const testResults = [];
            apiTestResult.successes.forEach((item) => {
                testResults.push(this.processTestResult(item, apiTestResult, apexTestClassIdSet, "Pass" /* ApexTestResultOutcome.Pass */));
            });
            apiTestResult.failures.forEach((item) => {
                testResults.push(this.processTestResult(item, apiTestResult, apexTestClassIdSet, "Fail" /* ApexTestResultOutcome.Fail */));
            });
            return { apexTestClassIdSet, testResults };
        }
        finally {
            utils_1.HeapMonitor.getInstance().checkHeapSize('syncTests.buildSyncTestResults');
        }
    }
    processTestResult(item, apiTestResult, apexTestClassIdSet, outcome) {
        const nms = item.namespace
            ? outcome === 'Fail'
                ? `${item.namespace}__`
                : `${item.namespace}.`
            : '';
        apexTestClassIdSet.add(item.id);
        const testResult = {
            id: '',
            queueItemId: '',
            stackTrace: item.stackTrace || '',
            message: item.message || '',
            asyncApexJobId: '',
            methodName: item.methodName,
            outcome: outcome,
            apexLogId: apiTestResult.apexLogId,
            apexClass: {
                id: item.id,
                name: item.name,
                namespacePrefix: item.namespace,
                fullName: `${nms}${item.name}`
            },
            runTime: item.time ?? 0,
            testTimestamp: '',
            fullName: `${nms}${item.name}.${item.methodName}`
        };
        if (outcome === "Fail" /* ApexTestResultOutcome.Fail */) {
            const diagnostic = item.message || item.stackTrace
                ? (0, diagnosticUtil_1.getSyncDiagnostic)(item)
                : null;
            if (diagnostic) {
                testResult.diagnostic = diagnostic;
            }
        }
        return testResult;
    }
}
exports.SyncTests = SyncTests;
__decorate([
    (0, utils_1.elapsedTime)()
], SyncTests.prototype, "runTests", null);
__decorate([
    (0, utils_1.elapsedTime)()
], SyncTests.prototype, "formatSyncResults", null);
__decorate([
    (0, utils_1.elapsedTime)()
], SyncTests.prototype, "buildSyncTestResults", null);
//# sourceMappingURL=syncTests.js.map