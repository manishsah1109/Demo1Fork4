"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.firstLevelMerge = exports.getEffectiveRegistry = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const collections_1 = require("../utils/collections");
const registryData = __importStar(require("./metadataRegistry.json"));
const presetMap_1 = require("./presets/presetMap");
/** combine the standard registration with any overrides specific in the sfdx-project.json */
const getEffectiveRegistry = (input) => (0, collections_1.deepFreeze)(removeEmptyStrings((0, exports.firstLevelMerge)(registryData, mergeVariants(input?.presets?.length ?? input?.registryCustomizations ? input : getProjectVariants(input?.projectDir)))));
exports.getEffectiveRegistry = getEffectiveRegistry;
/** read the project to get additional registry customizations and sourceBehaviorOptions */
const getProjectVariants = (projectDir) => {
    const logger = core_1.Logger.childFromRoot('variants:getProjectVariants');
    const projJson = maybeGetProject(projectDir);
    if (!projJson) {
        logger.debug('no project found, using standard registry');
        // there might not be a project at all and that's ok
        return {};
    }
    // there might not be any customizations in a project, so we default to the emptyRegistry
    const registryCustomizations = projJson.get('registryCustomizations') ?? emptyRegistry;
    const presets = [
        ...new Set([
            // TODO: deprecated, remove this
            ...(projJson.get('registryPresets') ?? []),
            ...(projJson.get('sourceBehaviorOptions') ?? []),
        ]),
    ];
    return logProjectVariants({
        registryCustomizations,
        presets: presets.map(loadPreset),
    }, projJson.getPath());
};
const mergeVariants = ({ registryCustomizations = emptyRegistry, presets }) => {
    const registryFromPresets = [...(presets ?? []), registryCustomizations].reduce((prev, curr) => (0, exports.firstLevelMerge)(prev, curr), emptyRegistry);
    return (0, exports.firstLevelMerge)(registryFromPresets, registryCustomizations);
};
const maybeGetProject = (projectDir) => {
    try {
        return core_1.SfProject.getInstance(projectDir ?? process.cwd()).getSfProjectJson();
    }
    catch (e) {
        return undefined;
    }
};
const loadPreset = (preset) => {
    const matchedPreset = presetMap_1.presetMap.get(preset);
    if (matchedPreset) {
        return matchedPreset;
    }
    throw core_1.SfError.create({
        message: `Failed to load preset "${preset}"`,
        name: 'InvalidPreset',
        actions: [
            `Use a valid preset.  Currently available presets are: [${[...presetMap_1.presetMap.keys()].join(', ')}]`,
            'Updating your CLI may be required to get newer presets',
        ],
    });
};
const emptyRegistry = {
    types: {},
    childTypes: {},
    suffixes: {},
    strictDirectoryNames: {},
};
/** merge the children of the top-level properties (ex: types, suffixes, etc) on 2 registries */
const firstLevelMerge = (original, overrides) => ({
    types: { ...original.types, ...(overrides.types ?? {}) },
    childTypes: { ...original.childTypes, ...(overrides.childTypes ?? {}) },
    suffixes: { ...original.suffixes, ...(overrides.suffixes ?? {}) },
    strictDirectoryNames: {
        ...original.strictDirectoryNames,
        ...(overrides.strictDirectoryNames ?? {}),
    },
});
exports.firstLevelMerge = firstLevelMerge;
const removeEmptyStrings = (reg) => ({
    types: reg.types,
    childTypes: removeEmptyString(reg.childTypes),
    suffixes: removeEmptyString(reg.suffixes),
    strictDirectoryNames: removeEmptyString(reg.strictDirectoryNames),
});
// presets can remove an entry by setting it to an empty string ex: { "childTypes": { "foo": "" } }
const removeEmptyString = (obj) => Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== ''));
// returns the projectVariants passed in.  Side effects: logger and telemetry only
const logProjectVariants = (variants, projectDir) => {
    const customizationTypes = Object.keys(variants.registryCustomizations?.types ?? {});
    const logger = core_1.Logger.childFromRoot('variants:logProjectVariants');
    if (customizationTypes.length) {
        logger.debug(`found registryCustomizations for types [${customizationTypes.join(',')}] in ${projectDir}`);
    }
    if (variants.presets?.length) {
        logger.debug(`using sourceBehaviorOptions [${variants.presets.join(',')}] in ${projectDir}`);
    }
    if (variants?.presets?.length ?? customizationTypes.length) {
        void core_1.Lifecycle.getInstance().emitTelemetry({
            library: 'SDR',
            eventName: 'RegistryVariants',
            presetCount: variants.presets?.length ?? 0,
            presets: variants.presets?.join(','),
            customizationsCount: customizationTypes.length,
            customizationsTypes: customizationTypes.join(','),
        });
    }
    else {
        logger.debug(`no registryCustomizations or sourceBehaviorOptions found in ${projectDir}`);
    }
    return variants;
};
//# sourceMappingURL=variants.js.map