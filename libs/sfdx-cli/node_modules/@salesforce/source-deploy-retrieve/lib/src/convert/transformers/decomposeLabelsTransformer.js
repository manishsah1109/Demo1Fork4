"use strict";
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LabelMetadataTransformer = exports.LabelsMetadataTransformer = void 0;
const kit_1 = require("@salesforce/kit");
const metadata_1 = require("../../utils/metadata");
const path_1 = require("../../utils/path");
const streams_1 = require("../streams");
const decomposed_1 = require("../../utils/decomposed");
const defaultMetadataTransformer_1 = require("./defaultMetadataTransformer");
/* Use for the metadata type CustomLabels  */
class LabelsMetadataTransformer extends defaultMetadataTransformer_1.DefaultMetadataTransformer {
    /** CustomLabels file => Array of CustomLabel WriteInfo (one for each label) */
    async toSourceFormat({ component, mergeSet }) {
        const labelType = this.registry.getTypeByName('CustomLabel');
        const partiallyAppliedPathCalculator = (0, path_1.calculateRelativePath)('source')({
            self: labelType,
        });
        const xml = (0, decomposed_1.unwrapAndOmitNS)('CustomLabels')(await component.parseXml());
        return (0, kit_1.ensureArray)(xml.labels) // labels could parse to a single object and not an array if there's only 1 label
            .filter(metadata_1.customLabelHasFullName)
            .map((l) => ({
            // split each label into a separate label file
            output: 
            // if present in the merge set, use that xml path, otherwise use the default path
            mergeSet?.getComponentFilenamesByNameAndType({ fullName: l.fullName, type: labelType.name })?.[0] ??
                partiallyAppliedPathCalculator(l.fullName)(`${l.fullName}.label-meta.xml`),
            source: new streams_1.JsToXml({ CustomLabel: l }),
        }));
    }
}
exports.LabelsMetadataTransformer = LabelsMetadataTransformer;
/* Use for the metadata type CustomLabel */
class LabelMetadataTransformer extends defaultMetadataTransformer_1.DefaultMetadataTransformer {
    async toMetadataFormat(component) {
        // only need to do this once
        this.context.decomposedLabels.customLabelsType ??= this.registry.getTypeByName('CustomLabels');
        this.context.decomposedLabels.transactionState.customLabelByFullName.set(component.fullName, (0, decomposed_1.unwrapAndOmitNS)('CustomLabel')(await component.parseXml()));
        return [];
    }
}
exports.LabelMetadataTransformer = LabelMetadataTransformer;
//# sourceMappingURL=decomposeLabelsTransformer.js.map