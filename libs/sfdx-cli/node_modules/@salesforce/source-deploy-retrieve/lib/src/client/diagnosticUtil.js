"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDeployDiagnostic = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_path_1 = require("node:path");
const core_1 = require("@salesforce/core");
const registry_1 = require("../registry/registry");
const parseDeployDiagnostic = (component, message) => {
    const { name: typeName } = component.type;
    const problem = getProblemFromMessage(message, component);
    switch (typeName) {
        case registry_1.registry.types.lightningcomponentbundle.name:
            return parseLwc(component, message, problem);
        case registry_1.registry.types.auradefinitionbundle.name:
            return parseAura(component, message, problem);
        default:
            if (typeof message !== 'string') {
                return parseDefault(component, message, problem);
            }
            throw new core_1.SfError(`Unable to parse deploy diagnostic with string message: ${message} for component ${component.fullName}`);
    }
};
exports.parseDeployDiagnostic = parseDeployDiagnostic;
const parseLwc = (component, message, problem) => {
    const filePath = messageHasProblemAndFilename(message) ? getFileEndingWith(message.fileName)(component) : undefined;
    const [line, col, lwcError] = (new RegExp(/(\[Line: (\d+), Col: (\d+)] )?(.*)/).exec(problem) ?? []).slice(2, 5);
    const [lineNumber, columnNumber] = [line, col].map(Number);
    return {
        problemType: 'Error',
        ...(filePath ? { filePath } : {}),
        ...(lineNumber && columnNumber && lwcError
            ? { lineNumber, columnNumber, error: appendErrorWithLocation(lwcError, lineNumber, columnNumber) }
            : { error: problem }),
    };
};
const parseAura = (component, message, problem) => {
    const filePath = messageHasProblemAndFilename(message) ? getFileEndingWith(message.fileName)(component) : undefined;
    const [lineNumber, columnNumber] = (new RegExp(/(\d+),\s?(\d+)/).exec(problem) ?? []).slice(1, 3).map(Number);
    return {
        problemType: 'Error',
        ...(filePath ? { filePath } : {}),
        ...(lineNumber >= 0 && columnNumber >= 0
            ? { lineNumber, columnNumber, error: appendErrorWithLocation(problem, lineNumber, columnNumber) }
            : { error: problem }),
    };
};
const parseDefault = (component, message, problem) => {
    const { problemType, fileName, lineNumber, columnNumber } = message;
    return {
        problemType: problemType ?? 'Error',
        ...(fileName ? { filePath: getFileEndingWith(fileName)(component) } : {}),
        ...(lineNumber && columnNumber
            ? {
                lineNumber: Number(lineNumber),
                columnNumber: Number(columnNumber),
                error: appendErrorWithLocation(problem, lineNumber, columnNumber),
            }
            : { error: problem }),
    };
};
const appendErrorWithLocation = (error, line, column) => `${error} (${line}:${column})`;
const messageHasProblemAndFilename = (message) => typeof message === 'object' && 'problem' in message && 'fileName' in message;
const getFileEndingWith = (fileName) => (component) => component.walkContent().find(endsWith((0, node_path_1.basename)(fileName))) ?? component.xml;
const endsWith = (ending) => (f) => f.endsWith(ending);
const getProblemFromMessage = (message, component) => {
    const problem = typeof message === 'string' ? message : message.problem;
    if (!problem) {
        throw new core_1.SfError(`Unable to parse deploy diagnostic with empty problem: ${JSON.stringify(message)} for component ${component.fullName}`);
    }
    return problem;
};
//# sourceMappingURL=diagnosticUtil.js.map